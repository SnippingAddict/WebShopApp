import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectorRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, Directive, DoCheck, EmbeddedViewRef, EventEmitter, Input, IterableChanges, IterableDiffer, IterableDiffers, NgModule, NgZone, OnChanges, OnDestroy, OnInit, Output, SimpleChanges, TemplateRef, TrackByFunction, ViewContainerRef, ViewRef, AfterViewInit } from '@angular/core';
import { DisplayContainerComponent } from './display.container';
import { HVirtualHelperComponent } from './horizontal.virtual.helper.component';
import { VirtualHelperComponent } from './virtual.helper.component';
import { IgxScrollInertiaModule } from './../scroll-inertia/scroll_inertia.directive';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from './for_of.sync.service';
import { Subject } from 'rxjs';
import { takeUntil, filter, throttleTime, first } from 'rxjs/operators';
import ResizeObserver from 'resize-observer-polyfill';
import { VirtualHelperBaseDirective } from './base.helper.component';
/**
 *  @publicApi
 */
export class IgxForOfContext {
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() { return this.index === 0; }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() { return this.index === this.count - 1; }
    /**
     * A function that returns whether the element is even or not
     */
    get even() { return this.index % 2 === 0; }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() { return !this.even; }
}
let IgxForOfDirective = class IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An @Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.onScrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
        */
        this.onContentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /** Height that is being virtualized. */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollTop = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    get displayContainer() {
        return this.dc.instance._viewContainer.element.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.func));
        }
        else {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.verticalScrollHandler));
        }
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        let totalSize = 0;
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        const dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            const factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(destructor, filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: true, trailing: true }))
                .subscribe(() => {
                this._zone.runTask(() => {
                    this.updateSizes();
                });
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => { this.onHScroll(evt); };
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                const hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new ResizeObserver(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollTop;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            const maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.ceil(this.scrollPosition);
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            const containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    updateSizes() {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    }
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                const newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                const totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            const reducer = (acc, val) => acc + val;
            if (this.igxForScrollOrientation === 'vertical') {
                const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                const hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    const containerSize = parseInt(this.igxForContainerSize, 10);
                    const maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    const currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = (currOffset - sumDiffs) + 'px';
                    this._adjustToIndex = null;
                }
            }
        }
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                /*recalculate and apply page size.*/
                if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollNext(prevStart);
                }
                else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        for (let i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
            const input = this.igxForOf[i];
            const embView = this._embeddedViews.shift();
            const cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
            const view = this.dc.instance._vcr.detach(0);
            this.dc.instance._vcr.insert(view);
            this._embeddedViews.push(embView);
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const input = this.igxForOf[i];
            const embView = this._embeddedViews.pop();
            const cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            const view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            this.dc.instance._vcr.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    }
    /**
     * @hidden
    */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const input = this.igxForOf[i];
            const embView = this._embeddedViews[j++];
            const cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        const prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() { return this._trackByFn; }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) { this._trackByFn = fn; }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embView = embeddedViewCopy.shift();
                const cntx = embView.context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserHeight() {
        const div = document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
        }
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            const size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set, index) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    _recalcScrollBarSize() {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because horizontalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because verticalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
        }
    }
    _calcHeight() {
        let height;
        if (this.heightCache) {
            height = this.heightCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    }
    _recalcOnContainerChange(changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => {
            this.cdr.markForCheck();
        });
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _updateScrollOffset() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    }
    _updateVScrollOffset() {
        let scrollOffset = 0;
        let currentScrollTop = this.scrollPosition;
        if (this._virtHeightRatio !== 1) {
            this._calcVirtualScrollTop(this.scrollPosition);
            currentScrollTop = this._virtScrollTop;
        }
        const vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    }
    _calcVirtualScrollTop(scrollTop) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollTop = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
    }
    _updateHScrollOffset() {
        let scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    _getItemSize(item, dimension) {
        const dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
};
IgxForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService }
];
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForOf", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForSizePropName", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForScrollOrientation", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForScrollContainer", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForContainerSize", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForItemSize", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForTotalItemCount", null);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onChunkLoad", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onScrollbarVisibilityChanged", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onContentSizeChange", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onDataChanged", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onBeforeViewDestroyed", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onChunkPreload", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForTrackBy", null);
IgxForOfDirective = __decorate([
    Directive({ selector: '[igxFor][igxForOf]' })
], IgxForOfDirective);
export { IgxForOfDirective };
export function getTypeNameForDebugging(type) {
    const name = 'name';
    return type[name] || typeof type;
}
let IgxGridForOfDirective = class IgxGridForOfDirective extends IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService);
        this.syncScrollService = syncScrollService;
        this.syncService = syncService;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.onDataChanging = new EventEmitter();
    }
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.syncService.isMaster(this)) {
            return this._sizesCache;
        }
        return this.syncService.sizesCache(this.igxForScrollOrientation);
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this)) {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        let newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(() => {
                this.recalcUpdateSizes();
                const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (this.scrollPosition !== 0) {
                    this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
                }
                else {
                    this._updateScrollOffset();
                }
            });
        }
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(() => {
            this.recalcUpdateSizes();
        });
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embView = embeddedViewCopy.shift();
                const cntx = embView.context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.syncService.isMaster(this)) {
            return super._calcMaxChunkSize();
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    }
};
IgxGridForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService },
    { type: IgxForOfSyncService }
];
__decorate([
    Input()
], IgxGridForOfDirective.prototype, "igxGridForOf", null);
__decorate([
    Output()
], IgxGridForOfDirective.prototype, "onDataChanging", void 0);
IgxGridForOfDirective = __decorate([
    Directive({
        selector: '[igxGridFor][igxGridForOf]'
    })
], IgxGridForOfDirective);
export { IgxGridForOfDirective };
/**
 * @hidden
 */
let IgxForOfModule = class IgxForOfModule {
};
IgxForOfModule = __decorate([
    NgModule({
        declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
            HVirtualHelperComponent, VirtualHelperBaseDirective],
        entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
        exports: [IgxForOfDirective, IgxGridForOfDirective],
        imports: [IgxScrollInertiaModule, CommonModule]
    })
], IgxForOfModule);
export { IgxForOfModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yX29mLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUMsT0FBTyxFQUFFLFlBQVksRUFBa0IsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRSxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDeEIsWUFBWSxFQUNaLFNBQVMsRUFDVCxPQUFPLEVBQ1AsZUFBZSxFQUNmLFlBQVksRUFDWixLQUFLLEVBQ0wsZUFBZSxFQUNmLGNBQWMsRUFDZCxlQUFlLEVBQ2YsUUFBUSxFQUNSLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULE1BQU0sRUFDTixNQUFNLEVBQ04sYUFBYSxFQUNiLFdBQVcsRUFDWCxlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLE9BQU8sRUFDUCxhQUFhLEVBQ2hCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBQ3RGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sY0FBYyxNQUFNLDBCQUEwQixDQUFDO0FBRXRELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxN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RCxDQUFDO0dBRVcsY0FBYyxDQUMxQjtTQURZLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyLvu79pbXBvcnQgeyBDb21tb25Nb2R1bGUsIE5nRm9yT2ZDb250ZXh0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50RmFjdG9yeSxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBEb0NoZWNrLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgSXRlcmFibGVDaGFuZ2VzLFxuICAgIEl0ZXJhYmxlRGlmZmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBOZ01vZHVsZSxcbiAgICBOZ1pvbmUsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVHJhY2tCeUZ1bmN0aW9uLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgVmlld1JlZixcbiAgICBBZnRlclZpZXdJbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9kaXNwbGF5LmNvbnRhaW5lcic7XG5pbXBvcnQgeyBIVmlydHVhbEhlbHBlckNvbXBvbmVudCB9IGZyb20gJy4vaG9yaXpvbnRhbC52aXJ0dWFsLmhlbHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVmlydHVhbEhlbHBlckNvbXBvbmVudCB9IGZyb20gJy4vdmlydHVhbC5oZWxwZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneFNjcm9sbEluZXJ0aWFNb2R1bGUgfSBmcm9tICcuLy4uL3Njcm9sbC1pbmVydGlhL3Njcm9sbF9pbmVydGlhLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi9mb3Jfb2Yuc3luYy5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZmlsdGVyLCB0aHJvdHRsZVRpbWUsIGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgfSBmcm9tICcuL2Jhc2UuaGVscGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IGNsYXNzIElneEZvck9mQ29udGV4dDxUPiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgcHVibGljICRpbXBsaWNpdDogVCxcbiAgICAgICBwdWJsaWMgaW5kZXg6IG51bWJlcixcbiAgICAgICBwdWJsaWMgY291bnQ6IG51bWJlclxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGZpcnN0IG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBmaXJzdCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7IH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGxhc3Qgb3Igbm90XG4gICAgICovXG4gICAgZ2V0IGxhc3QoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTsgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyBldmVuIG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBldmVuKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgb2RkIG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBvZGQoKTogYm9vbGVhbiB7IHJldHVybiAhdGhpcy5ldmVuOyB9XG5cbn1cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2lneEZvcl1baWd4Rm9yT2ZdJyB9KVxuZXhwb3J0IGNsYXNzIElneEZvck9mRGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBkYXRhIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yT2Y6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgcHJvcGVydHkgbmFtZSBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHNpemUgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNpemVQcm9wTmFtZTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgc2Nyb2xsIG9yaWVudGF0aW9uLlxuICAgICAqIFNjcm9sbCBvcmllbnRhdGlvbiBjYW4gYmUgXCJ2ZXJ0aWNhbFwiIG9yIFwiaG9yaXpvbnRhbFwiLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPSAndmVydGljYWwnO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWxseSBwYXNzIHRoZSBwYXJlbnQgYGlneEZvcmAgaW5zdGFuY2UgdG8gY3JlYXRlIGEgdmlydHVhbCB0ZW1wbGF0ZSBzY3JvbGxpbmcgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjc2Nyb2xsQ29udGFpbmVyIGlneEZvciBsZXQtcm93RGF0YSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIid2ZXJ0aWNhbCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIlxuICAgICAqICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCI+XG4gICAgICogICAgICAgPGRpdiBbc3R5bGUuZGlzcGxheV09XCInZmxleCdcIiBbc3R5bGUuaGVpZ2h0XT1cIic1MHB4J1wiPlxuICAgICAqICAgICAgICAgICA8bmctdGVtcGxhdGUgI2NoaWxkQ29udGFpbmVyIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCJcbiAgICAgKiAgICAgICAgICAgICAgIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwicGFyZW50VmlydERpclwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgPGRpdiBbc3R5bGUubWluLXdpZHRoXT1cIic1MHB4J1wiPnt7cm93SW5kZXh9fSA6IHt7aXRlbS50ZXh0fX08L2Rpdj5cbiAgICAgKiAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNjcm9sbENvbnRhaW5lcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgcHgtYWZmaXhlZCBzaXplIG9mIHRoZSBjb250YWluZXIgYWxvbmcgdGhlIGF4aXMgb2Ygc2Nyb2xsaW5nLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGlzIHZhbHVlIGlzIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIGlzIHRoZSBoZWlnaHQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCJcbiAgICAgKiAgICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckNvbnRhaW5lclNpemU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHB4LWFmZml4ZWQgc2l6ZSBvZiB0aGUgaXRlbSBhbG9uZyB0aGUgYXhpcyBvZiBzY3JvbGxpbmcuXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoaXMgdmFsdWUgaXMgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgaXMgdGhlIGhlaWdodCBvciB0aGUgcm93LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckl0ZW1TaXplOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIHZpcnR1YWwgZGF0YSBpdGVtcywgd2hlbiB1c2luZyByZW1vdGUgc2VydmljZS5cbiAgICAgKiBTaW1pbGFyIHRvIHRoZSBwcm9wZXJ0eSB0b3RhbEl0ZW1Db3VudCwgYnV0IHRoaXMgd2lsbCBhbGxvdyBzZXR0aW5nIHRoZSBkYXRhIGNvdW50IGludG8gdGhlIHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhIHwgYXN5bmNcIiBbaWd4Rm9yVG90YWxJdGVtQ291bnRdPVwiY291bnQgfCBhc3luY1wiXG4gICAgICogIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIiBbaWd4Rm9ySXRlbVNpemVdPVwiJzUwcHgnXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBpZ3hGb3JUb3RhbEl0ZW1Db3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1Db3VudDtcbiAgICB9XG4gICAgc2V0IGlneEZvclRvdGFsSXRlbUNvdW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy50b3RhbEl0ZW1Db3VudCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRjOiBDb21wb25lbnRSZWY8RGlzcGxheUNvbnRhaW5lckNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGlyZWN0aXZlLiBJdCBjb250YWlucyBgc3RhcnRJbmRleGAgYW5kIGBjaHVua1NpemVgLlxuICAgICAqIHN0YXRlLnN0YXJ0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gYXQgd2hpY2ggdGhlIGN1cnJlbnQgdmlzaWJsZSBjaHVuayBiZWdpbnMuXG4gICAgICogc3RhdGUuY2h1bmtTaXplIC0gVGhlIG51bWJlciBvZiBpdGVtcyB0aGUgY3VycmVudCB2aXNpYmxlIGNodW5rIGhvbGRzLlxuICAgICAqIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgcmVtb3RlIHZpcnR1YWxpemF0aW9uIGFzIHRoZXkgcHJvdmlkZSB0aGUgbmVjZXNzYXJ5IHN0YXRlIGluZm9ybWF0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncmlkU3RhdGUgPSB0aGlzLnBhcmVudFZpcnREaXIuc3RhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRlOiBJRm9yT2ZTdGF0ZSA9IHtcbiAgICAgICAgc3RhcnRJbmRleDogMCxcbiAgICAgICAgY2h1bmtTaXplOiAwXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIHZpcnR1YWwgZGF0YSBpdGVtcywgd2hlbiB1c2luZyByZW1vdGUgc2VydmljZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnRvdGFsSXRlbUNvdW50ID0gZGF0YS5Db3VudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG90YWxJdGVtQ291bnQ6IG51bWJlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgYSBuZXcgY2h1bmsgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChvbkNodW5rTG9hZCk9XCJjaHVua0xvYWQoJGV2ZW50KVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNodW5rTG9hZChlKXtcbiAgICAgKiBhbGVydChcImNodW5rIGxvYWRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNodW5rTG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHNjcm9sbGJhciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIHJlbmRlcmVkIGNvbnRlbnQgc2l6ZSBvZiB0aGUgaWd4Rm9yT2YgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNvbnRlbnRTaXplQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChvbkRhdGFDaGFuZ2VkKT1cImRhdGFDaGFuZ2VkKCRldmVudClcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBkYXRhQ2hhbmdlZChlKXtcbiAgICAgKiBhbGVydChcImRhdGEgY2hhbmdlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkRhdGFDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25CZWZvcmVWaWV3RGVzdHJveWVkID0gbmV3IEV2ZW50RW1pdHRlcjxFbWJlZGRlZFZpZXdSZWY8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBvbiBjaHVuayBsb2FkaW5nIHRvIGVtaXQgdGhlIGN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gLSBzdGFydEluZGV4LCBlbmRJbmRleCwgdG90YWxDb3VudC5cbiAgICAgKiBDYW4gYmUgdXNlZCBmb3IgaW1wbGVtZW50aW5nIHJlbW90ZSBsb2FkIG9uIGRlbWFuZCBmb3IgdGhlIGlneEZvciBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChvbkNodW5rUHJlbG9hZCk9XCJjaHVua1ByZWxvYWQoJGV2ZW50KVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNodW5rUHJlbG9hZChlKXtcbiAgICAgKiBhbGVydChcImNodW5rIGlzIGxvYWRpbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25DaHVua1ByZWxvYWQgPSBuZXcgRXZlbnRFbWl0dGVyPElGb3JPZlN0YXRlPigpO1xuICAgIHByb3RlY3RlZCBmdW5jO1xuICAgIHByb3RlY3RlZCBfc2l6ZXNDYWNoZTogbnVtYmVyW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsQ29tcG9uZW50OiBWaXJ0dWFsSGVscGVyQmFzZURpcmVjdGl2ZTtcbiAgICBwcm90ZWN0ZWQgX2RpZmZlcjogSXRlcmFibGVEaWZmZXI8VD4gfCBudWxsID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX3RyYWNrQnlGbjogVHJhY2tCeUZ1bmN0aW9uPFQ+O1xuICAgIHByb3RlY3RlZCBoZWlnaHRDYWNoZSA9IFtdO1xuICAgIHByaXZhdGUgX2FkanVzdFRvSW5kZXg7XG4gICAgcHJpdmF0ZSBNQVhfUEVSRl9TQ1JPTExfRElGRiA9IDQ7XG5cblxuICAgIHB1YmxpYyBnZXQgZGlzcGxheUNvbnRhaW5lcigpOiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHZpcnR1YWxIZWxwZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgc2l6ZXNDYWNoZSgpOiBudW1iZXJbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplc0NhY2hlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgc2V0IHNpemVzQ2FjaGUodmFsdWU6IG51bWJlcltdKSB7XG4gICAgICAgIHRoaXMuX3NpemVzQ2FjaGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBfaXNTY3JvbGxlZFRvQm90dG9tKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2Nyb2xsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAvLyBVc2UgPT09IGFuZCBub3QgPj0gYmVjYXVzZSBgc2Nyb2xsVG9wICsgY29udGFpbmVyIHNpemVgIGNhbid0IGJlIGJpZ2dlciB0aGFuIGBzY3JvbGxIZWlnaHRgLCB1bmxlc3Mgc29tZXRoaW5nIGlzbid0IHVwZGF0ZWQuXG4gICAgICAgIC8vIEFsc28gdXNlIE1hdGgucm91bmQgYmVjYXVzZSBDaHJvbWUgaGFzIHNvbWUgaW5jb25zaXN0ZW5jaWVzIGFuZCBgc2Nyb2xsVG9wICsgY29udGFpbmVyYCBjYW4gYmUgZmxvYXQgd2hlbiB6b29taW5nIHRoZSBwYWdlLlxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmdldFNjcm9sbCgpLnNjcm9sbFRvcCArIHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSkgPT09IHNjcm9sbEhlaWdodDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBfaXNBdEJvdHRvbUluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JPZiAmJiB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSA+IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHByb3BlcnRpZXMgcmVsYXRlZCB0byB2aXJ0dWFsIGhlaWdodCBoYW5kbGluZyBkdWUgdG8gYnJvd3NlciBsaW1pdGF0aW9uXG4gICAgLyoqIE1heGltdW0gaGVpZ2h0IGZvciBhbiBlbGVtZW50IG9mIHRoZSBicm93c2VyLiAqL1xuICAgIHByaXZhdGUgX21heEhlaWdodDtcblxuICAgIC8qKiBIZWlnaHQgdGhhdCBpcyBiZWluZyB2aXJ0dWFsaXplZC4gKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRIZWlnaHQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmF0aW8gZm9yIGhlaWdodCB0aGF0J3MgYmVpbmcgdmlydHVhbGl6YWVkIGFuZCB0aGUgb25lIHZpc2libGVcbiAgICAgKiBJZiBfdmlydEhlaWdodFJhdGlvID0gMSwgdGhlIHZpc2libGUgaGVpZ2h0IGFuZCB0aGUgdmlydHVhbGl6ZWQgYXJlIHRoZSBzYW1lLCBhbHNvIF9tYXhIZWlnaHQgPiBfdmlydEhlaWdodC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF92aXJ0SGVpZ2h0UmF0aW8gPSAxO1xuXG4gICAgLyoqIEludGVybmFsIHRyYWNrIGZvciBzY3JvbGwgdG9wIHRoYXQgaXMgYmVpbmcgdmlydHVhbGl6ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRTY3JvbGxUb3AgPSAwO1xuXG4gICAgLyoqIElmIHRoZSBuZXh0IG9uU2Nyb2xsIGV2ZW50IGlzIHRyaWdnZXJlZCBkdWUgdG8gaW50ZXJuYWwgc2V0dGluZyBvZiBzY3JvbGxUb3AgKi9cbiAgICBwcm90ZWN0ZWQgX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgIC8vIEVuZCBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdmlydHVhbCBoZWlnaHQgaGFuZGxpbmdcblxuICAgIHByb3RlY3RlZCBfZW1iZWRkZWRWaWV3czogQXJyYXk8RW1iZWRkZWRWaWV3UmVmPGFueT4+ID0gW107XG5cbiAgICBwcm90ZWN0ZWQgY29udGVudFJlc2l6ZU5vdGlmeSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgcHJvdGVjdGVkIGNvbnRlbnRPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPE5nRm9yT2ZDb250ZXh0PFQ+PixcbiAgICAgICAgcHJvdGVjdGVkIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHByaXZhdGUgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfem9uZTogTmdab25lLFxuICAgICAgICBwcm90ZWN0ZWQgc3luY1Njcm9sbFNlcnZpY2U6IElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgaXNSZW1vdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbUNvdW50ICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBvc2l0aW9uID0gZGlyZWN0aXZlLnNjcm9sbFBvc2l0aW9uO1xuICAgICAqIGRpcmVjdGl2ZS5zY3JvbGxQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2Nyb2xsUG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudDtcbiAgICB9XG4gICAgcHVibGljIHNldCBzY3JvbGxQb3NpdGlvbih2YWw6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsID09PSB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHRoaXMuc2Nyb2xsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5mdW5jKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyB2ZXJ0aWNhbFNjcm9sbEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblNjcm9sbChldmVudCk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzU2Nyb2xsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPiBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgY29uc3QgdmMgPSB0aGlzLmlneEZvclNjcm9sbENvbnRhaW5lciA/IHRoaXMuaWd4Rm9yU2Nyb2xsQ29udGFpbmVyLl92aWV3Q29udGFpbmVyIDogdGhpcy5fdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgPSB0aGlzLmlneEZvclNpemVQcm9wTmFtZSB8fCAnd2lkdGgnO1xuXG4gICAgICAgIGNvbnN0IGRjRmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50PiA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRGlzcGxheUNvbnRhaW5lckNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGMgPSB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChkY0ZhY3RvcnksIDApO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbERpcmVjdGlvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb247XG4gICAgICAgIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBPbiBFZGdlIGFuZCBJRSB3aGVuIHNjcm9sbGluZyBvbiB0b3VjaCB0aGUgcGFnZSBzY3JvbGwgaW5zdGVhZCBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b3RhbFNpemUgPSB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLmdldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2h1bmtTaXplID0gdGhpcy5fY2FsY3VsYXRlQ2h1bmtTaXplKCk7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLm5vdFZpcnR1YWwgPSAhKHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAmJiB0aGlzLnN0YXRlLmNodW5rU2l6ZSA8IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbENvbXBvbmVudCAmJiAhdGhpcy5zY3JvbGxDb21wb25lbnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gTWF0aC5taW4odGhpcy5nZXRJbmRleEF0KHRoaXMuc2Nyb2xsUG9zaXRpb24sIHRoaXMuc2l6ZXNDYWNoZSwgMCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gdGhpcy5zdGF0ZS5jaHVua1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDsgaSA8IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkVmlldyA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5jcmVhdGVFbWJlZGRlZFZpZXcoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICBuZXcgSWd4Rm9yT2ZDb250ZXh0PFQ+KGlucHV0LCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYmVkZGVkVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFZpcnR1YWxIZWxwZXJDb21wb25lbnQ+ID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShWaXJ0dWFsSGVscGVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdmMuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpLmluc3RhbmNlO1xuICAgICAgICAgICAgdGhpcy5fbWF4SGVpZ2h0ID0gdGhpcy5fY2FsY01heEJyb3dzZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSB0aGlzLmlneEZvck9mID8gdGhpcy5fY2FsY0hlaWdodCgpIDogMDtcbiAgICAgICAgICAgIHRoaXMuc3luY1Njcm9sbFNlcnZpY2Uuc2V0U2Nyb2xsTWFzdGVyKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24sIHRoaXMuc2Nyb2xsQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyID0gdGhpcy52ZXJ0aWNhbFNjcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RydWN0b3IgPSB0YWtlVW50aWw8YW55Pih0aGlzLmRlc3Ryb3kkKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFJlc2l6ZU5vdGlmeS5waXBlKGRlc3RydWN0b3IsXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGggPiAwKSxcbiAgICAgICAgICAgIHRocm90dGxlVGltZSg0MCwgdW5kZWZpbmVkLCB7bGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWV9KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuVGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gKGV2dCkgPT4geyB0aGlzLm9uSFNjcm9sbChldnQpOyB9O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLmdldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodkZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8SFZpcnR1YWxIZWxwZXJDb21wb25lbnQ+ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShIVmlydHVhbEhlbHBlckNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB2Yy5jcmVhdGVDb21wb25lbnQoaHZGYWN0b3J5KS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gdG90YWxTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY1Njcm9sbFNlcnZpY2Uuc2V0U2Nyb2xsTWFzdGVyKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24sIHRoaXMuc2Nyb2xsQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uuc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMuY29udGVudFJlc2l6ZU5vdGlmeS5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyLm9ic2VydmUodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBjb25zdCBmb3JPZiA9ICdpZ3hGb3JPZic7XG4gICAgICAgIGlmIChmb3JPZiBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbZm9yT2ZdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5pZ3hGb3JUcmFja0J5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7Z2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpfVwiLlxuICAgICAgICAgICAgICAgICAgICAgTmdGb3Igb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gJ2lneEZvckl0ZW1TaXplJztcbiAgICAgICAgaWYgKGRlZmF1bHRJdGVtU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2RlZmF1bHRJdGVtU2l6ZV0uZmlyc3RDaGFuZ2UgJiZcbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgaXRlbSBzaXplIGNoYW5nZWQuXG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9ICdpZ3hGb3JDb250YWluZXJTaXplJztcbiAgICAgICAgaWYgKGNvbnRhaW5lclNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tjb250YWluZXJTaXplXS5maXJzdENoYW5nZSAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNhbGNPbkNvbnRhaW5lckNoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8vICByZS1pbml0IGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpemVDYWNoZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFDaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyB0aGUgc2Nyb2xsIHRodW1iIHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuYWRkU2Nyb2xsVG9wKDUpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBhZGRUb3AgbmVnYXRpdmUgdmFsdWUgdG8gc2Nyb2xsIHVwIGFuZCBwb3NpdGl2ZSB0byBzY3JvbGwgZG93bjtcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkU2Nyb2xsVG9wKGFkZFRvcDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChhZGRUb3AgPT09IDAgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydFNjcm9sbFRvcDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBtYXhWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydEhlaWdodCAtIGNvbnRhaW5lclNpemU7XG5cbiAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmlydFNjcm9sbFRvcCArPSBhZGRUb3A7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsVG9wID4gMCA/XG4gICAgICAgICAgICAodGhpcy5fdmlydFNjcm9sbFRvcCA8IG1heFZpcnRTY3JvbGxUb3AgPyB0aGlzLl92aXJ0U2Nyb2xsVG9wIDogbWF4VmlydFNjcm9sbFRvcCkgOlxuICAgICAgICAgICAgMDtcblxuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uICs9IGFkZFRvcCAvIHRoaXMuX3ZpcnRIZWlnaHRSYXRpbztcbiAgICAgICAgaWYgKE1hdGguYWJzKGFkZFRvcCAvIHRoaXMuX3ZpcnRIZWlnaHRSYXRpbykgPCAxKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWwgc2Nyb2xsIGRlbHRhIHRoYXQgd2FzIGFkZGVkIGlzIHNtYWxsZXIgdGhhbiAxIGFuZCBvblNjcm9sbCBoYW5kbGVyIGRvZXNuJ3QgdHJpZ2dlciB3aGVuIHNjcm9sbGluZyA8IDFweFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxUb3ApO1xuICAgICAgICAgICAgLy8gc2Nyb2xsT2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0ICE9PSBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCkgPyBzY3JvbGxPZmZzZXQgOiAwO1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gLShzY3JvbGxPZmZzZXQpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heFJlYWxTY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodCAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIGlmICgodGhpcy5fdmlydFNjcm9sbFRvcCA+IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA9PT0gMCkgfHxcbiAgICAgICAgICAgICh0aGlzLl92aXJ0U2Nyb2xsVG9wIDwgbWF4VmlydFNjcm9sbFRvcCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID09PSBtYXhSZWFsU2Nyb2xsVG9wKSkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBhdCB0aGUgdG9wIG9yIGJvdHRvbSwgYnV0IHZpcnR1YWwgb25lIGlzIG5vdCBhdCB0aGUgdG9wIG9yIGJvdHRvbSAodGhlcmUncyBtb3JlIHRvIHNjcm9sbClcbiAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIGFjdHVhbCBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gdGhlIHZpcnR1YWwgc2Nyb2xsLlxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpcnRTY3JvbGxUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlydFNjcm9sbFRvcCA9PT0gMCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgYXQgdGhlIHRvcCwgYnV0IHZpcnR1YWwgc2Nyb2xsIGlzLiBKdXN0IHVwZGF0ZSB0aGUgYWN0dWFsIHNjcm9sbFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlydFNjcm9sbFRvcCA9PT0gbWF4VmlydFNjcm9sbFRvcCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uIDwgbWF4UmVhbFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgYXQgdGhlIGJvdHRvbSwgYnV0IHZpcnR1YWwgc2Nyb2xsIGlzLiBKdXN0IHVwZGF0ZSB0aGUgYWN1YWwgc2Nyb2xsXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gbWF4UmVhbFNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdmlydFNjcm9sbFRvcCAhPT0gb3JpZ2luYWxWaXJ0U2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFRvKDUpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxUbyhpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gKHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgaXNQcmV2SXRlbSA9IGluZGV4IDwgdGhpcy5zdGF0ZS5zdGFydEluZGV4IHx8IHRoaXMuc2Nyb2xsUG9zaXRpb24gPiB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdO1xuICAgICAgICBsZXQgbmV4dFNjcm9sbCA9IGlzUHJldkl0ZW0gPyB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdIDogdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAobmV4dFNjcm9sbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gbmV4dFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0SGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgICAgIGlmIChuZXh0U2Nyb2xsID4gbWF4VmlydFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIG5leHRTY3JvbGwgPSBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxUb3AgPSBuZXh0U2Nyb2xsO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpcnRTY3JvbGxUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW87XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RUb0luZGV4ID0gIWlzUHJldkl0ZW0gPyBpbmRleCA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBpdGVtIGludG8gdGhlIGFwcHJvcHJpYXRlIG5leHQgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgdGhlIHJpZ2h0IGNvbHVtbiBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIHRoZSBsb3dlciByb3cuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxOZXh0KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbE5leHQoKSB7XG4gICAgICAgIGNvbnN0IHNjciA9IE1hdGguY2VpbCh0aGlzLnNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLmdldEluZGV4QXQoXG4gICAgICAgICAgICBzY3IgKyBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyhlbmRJbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgaXRlbSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBwcmV2aW91cyBkaXJlY3Rpb24uXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoYXQgd2lsbCBiZSB0aGUgbGVmdCBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyB0aGUgdXBwZXIgcm93LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsUHJldigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxQcmV2KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuc3RhdGUuc3RhcnRJbmRleCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIHBhZ2UgaW50byB0aGUgYXBwcm9wcmlhdGUgbmV4dCBkaXJlY3Rpb24uXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoYXQgd2lsbCBiZSBvbmUgdmlldyB0byB0aGUgcmlnaHQgYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyBvbmUgdmlldyB0byB0aGUgYm90dG9tLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsTmV4dFBhZ2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsTmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gKz0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNjcm9sbFRvcChwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBwYWdlIGludG8gdGhlIGFwcHJvcHJpYXRlIHByZXZpb3VzIGRpcmVjdGlvbi5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhhdCB3aWxsIGJlIG9uZSB2aWV3IHRvIHRoZSBsZWZ0IGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgb25lIHZpZXcgdG8gdGhlIHRvcC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFByZXZQYWdlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFByZXZQYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uIC09IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IChwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNjcm9sbFRvcCgtY29udGFpbmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENvbHVtblNjcm9sbExlZnQoY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtjb2xJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIGZ1bGx5IHZpc2libGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRJdGVtQ291bnRJblZpZXcoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SXRlbUNvdW50SW5WaWV3KCkge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdChcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24sXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBvc2l0aW9uIC0gdGhpcy5zaXplc0NhY2hlW3N0YXJ0SW5kZXhdID4gMCkge1xuICAgICAgICAgICAgLy8gZmlzcnQgaXRlbSBpcyBub3QgZnVsbHkgaW4gdmlld1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiArIHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApLFxuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNjcm9sbGJhciBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIGVpdGhlciBhIHZlcnRpY2FsIG9yIGhvcml6b250YWwgc2Nyb2xsYmFyIGRlcGVuZGluZyBvbiB0aGUgc3BlY2lmaWVkIGlneEZvclNjcm9sbE9yaWVudGF0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBkaXIuZ2V0U2Nyb2xsKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldFNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldFNpemVBdCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2l6ZUF0KGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRTY3JvbGxGb3JJbmRleCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsRm9ySW5kZXgoaW5kZXg6IG51bWJlciwgYm90dG9tPzogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IGJvdHRvbSA/IE1hdGgubWF4KDAsIHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gY29udGFpbmVyU2l6ZSkgOiB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdO1xuICAgICAgICByZXR1cm4gc2Nyb2xsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyB2ZXJ0aWNhbGx5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0LCAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2JTY3JvbGxJbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxUb3AoZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2U3RhcnRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxUb3ApO1xuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG5cbiAgICAgICAgdGhpcy5kYy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwcmV2U3RhcnRJbmRleCAhPT0gdGhpcy5zdGF0ZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdXBkYXRlU2l6ZXMoKSB7XG4gICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICB0aGlzLm9uQ29udGVudFNpemVDaGFuZ2UuZW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJlY2FjdWxhdGVzIGFuZCB1cGRhdGVzIGNhY2hlIHNpemVzLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWNhbGNVcGRhdGVTaXplcygpIHtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGRpZmZzID0gW107XG4gICAgICAgIGxldCB0b3RhbERpZmYgPSAwO1xuICAgICAgICBjb25zdCBsID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJOb2RlcyA9IHRoaXMuX2VtYmVkZGVkVmlld3MubWFwKHZpZXcgPT5cbiAgICAgICAgICAgIHZpZXcucm9vdE5vZGVzLmZpbmQobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgfHwgdmlldy5yb290Tm9kZXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJOb2RlID0gck5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHJOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IHJOb2RlLm9mZnNldEhlaWdodCB8fCBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyBpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pZ3hGb3JPZltpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbCA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyB0aGlzLmhlaWdodENhY2hlW2luZGV4XSA6IHRoaXMuaWd4Rm9yT2ZbaW5kZXhdW2RpbWVuc2lvbl07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGggOiByTm9kZS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlW2luZGV4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mW2luZGV4XVtkaW1lbnNpb25dID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRGlmZiA9IG5ld1ZhbCAtIG9sZFZhbDtcbiAgICAgICAgICAgICAgICBkaWZmcy5wdXNoKGN1cnJEaWZmKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpZmYgKz0gY3VyckRpZmY7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgICBpZiAoTWF0aC5hYnModG90YWxEaWZmKSA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIDE7IGogPCB0aGlzLnNpemVzQ2FjaGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGVbal0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc2NyQmFyIGhlaWdodHMvd2lkdGhzXG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGgsIDEwKSArIHRvdGFsRGlmZjtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoID0gdG90YWxXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjYywgdmFsKSA9PiBhY2MgKyB2YWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjclRvQm90dG9tID0gdGhpcy5faXNTY3JvbGxlZFRvQm90dG9tICYmICF0aGlzLmRjLmluc3RhbmNlLm5vdFZpcnR1YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgaFN1bSA9IHRoaXMuaGVpZ2h0Q2FjaGUucmVkdWNlKHJlZHVjZXIpO1xuICAgICAgICAgICAgICAgIGlmIChoU3VtID4gdGhpcy5fbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRIZWlnaHRSYXRpbyA9IGhTdW0gLyB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSBNYXRoLm1pbih0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplICsgdG90YWxEaWZmLCB0aGlzLl9tYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRIZWlnaHQgPSBoU3VtO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY3JUb0JvdHRvbSAmJiAhdGhpcy5faXNBdEJvdHRvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsVG9wID0gbWF4VmlydFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG1heFZpcnRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FkanVzdFRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBzY3JvbGxlZCB0byBzcGVjaWZpYyBpbmRleCB3aGVyZSBhZnRlciBzY3JvbGwgaGVpZ2h0cyBhcmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGFkanVzdCB0aGUgb2Zmc2V0cyBzbyB0aGF0IGl0ZW0gaXMgbGFzdCBpbiB2aWV3LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVzVG9JbmRleCA9IHRoaXMuX2FkanVzdFRvSW5kZXggLSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1EaWZmcyA9IGRpZmZzLnNsaWNlKDAsIHVwZGF0ZXNUb0luZGV4KS5yZWR1Y2UocmVkdWNlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJPZmZzZXQgPSBwYXJzZUludCh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gKGN1cnJPZmZzZXQgLSBzdW1EaWZmcykgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RUb0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpeGVkVXBkYXRlQWxsRWxlbWVudHMoaW5TY3JvbGxUb3A6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgaW5TY3JvbGxUb3AsXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXdTdGFydCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gY291bnQpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gY291bnQgLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTdGFydCAtIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gbmV3U3RhcnQ7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtQcmVsb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAvKnJlY2FsY3VsYXRlIGFuZCBhcHBseSBwYWdlIHNpemUuKi9cbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAgJiYgZGlmZiA8PSB0aGlzLk1BWF9QRVJGX1NDUk9MTF9ESUZGKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUFwcGx5U2Nyb2xsTmV4dChwcmV2U3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDAgJiYgTWF0aC5hYnMoZGlmZikgPD0gdGhpcy5NQVhfUEVSRl9TQ1JPTExfRElGRikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVBcHBseVNjcm9sbFByZXYocHJldlN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkQXBwbHlTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluU2Nyb2xsVG9wIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyBkb3duL3JpZ2h0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxOZXh0KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcHJldkluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4IC0gcHJldkluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgY250eCA9IGVtYlZpZXcuY29udGV4dDtcbiAgICAgICAgICAgIGNudHguJGltcGxpY2l0ID0gaW5wdXQ7XG4gICAgICAgICAgICBjbnR4LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpO1xuICAgICAgICAgICAgY250eC5jb3VudCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdmlldzogVmlld1JlZiA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5kZXRhY2goMCk7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92Y3IuaW5zZXJ0KHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYlZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyB1cC9sZWZ0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxQcmV2KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSBwcmV2SW5kZXggLSAxOyBpID49IHRoaXMuc3RhdGUuc3RhcnRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2ldO1xuICAgICAgICAgICAgY29uc3QgZW1iVmlldyA9IHRoaXMuX2VtYmVkZGVkVmlld3MucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBjbnR4ID0gZW1iVmlldy5jb250ZXh0O1xuICAgICAgICAgICAgY250eC4kaW1wbGljaXQgPSBpbnB1dDtcbiAgICAgICAgICAgIGNudHguaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3OiBWaWV3UmVmID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmRldGFjaCh0aGlzLmRjLmluc3RhbmNlLl92Y3IubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92Y3IuaW5zZXJ0KHZpZXcsIDApO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy51bnNoaWZ0KGVtYlZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHJvdGVjdGVkIGdldENvbnRleHRJbmRleChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JlbW90ZSA/IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihpbnB1dCkgOiB0aGlzLmlneEZvck9mLmluZGV4T2YoaW5wdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBUaGUgZnVuY3Rpb24gYXBwbGllcyBhbiBvcHRpbWl6ZWQgc3RhdGUgY2hhbmdlIHRocm91Z2ggY29udGV4dCBjaGFuZ2UgZm9yIGVhY2ggdmlld1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaXhlZEFwcGx5U2Nyb2xsKCk6IHZvaWQge1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2ldO1xuICAgICAgICAgICAgY29uc3QgZW1iVmlldyA9IHRoaXMuX2VtYmVkZGVkVmlld3NbaisrXTtcbiAgICAgICAgICAgIGNvbnN0IGNudHggPSAoZW1iVmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55PikuY29udGV4dDtcbiAgICAgICAgICAgIGNudHguJGltcGxpY2l0ID0gaW5wdXQ7XG4gICAgICAgICAgICBjbnR4LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpO1xuICAgICAgICAgICAgY250eC5jb3VudCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhvcml6b250YWxseVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvbkhTY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgLyogaW4gY2VydGFpbiBzaXR1YXRpb25zIHRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlICovXG4gICAgICAgIGlmICghcGFyc2VJbnQodGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIC8vIFVwZGF0aW5nIGhvcml6b250YWwgY2h1bmtzXG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyhldmVudC50YXJnZXQuc2Nyb2xsTGVmdCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLmRjLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHByZXZTdGFydEluZGV4ICE9PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMub25DaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgY2hhbmdlcyBpbiB0aGUgaXRlbXMgY29sbGVjdGlvbi5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBvYmplY3QgcmVmZXJlbmNlcyBhcmUgY29tcGFyZWQuIEhvd2V2ZXIgdGhpcyBjYW4gYmUgb3B0aW1pemVkIGlmIHlvdSBoYXZlIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICogdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZiB0aGUgb2JqZWN0IHJlZiBvciBpZiB5b3UgaGF2ZSBzb21lIG90aGVyIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIGluIHRoZSBpdGVtIG9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFja2VkIGZvciBjaGFuZ2VzLlxuICAgICAqIFRoaXMgb3B0aW9uIGlzIHNpbWlsYXIgdG8gbmdGb3JUcmFja0J5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0cmFja0Z1bmMgPSB0aGlzLnBhcmVudFZpcnREaXIuaWd4Rm9yVHJhY2tCeTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBpZ3hGb3JUcmFja0J5KCk6IFRyYWNrQnlGdW5jdGlvbjxUPiB7IHJldHVybiB0aGlzLl90cmFja0J5Rm47IH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgY2hhbmdlcyBpbiB0aGUgaXRlbXMgY29sbGVjdGlvbi5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBzZXQgaW4gc2NlbmFyaW9zIHdoZXJlIHlvdSB3YW50IHRvIG9wdGltaXplIG9yXG4gICAgICogY3VzdG9taXplIHRoZSB0cmFja2luZyBvZiBjaGFuZ2VzIGZvciB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogVGhlIGlneEZvclRyYWNrQnkgZnVuY3Rpb24gdGFrZXMgdGhlIGluZGV4IGFuZCB0aGUgY3VycmVudCBpdGVtIGFzIGFyZ3VtZW50cyBhbmQgbmVlZHMgdG8gcmV0dXJuIHRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBpdGVtLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuaWd4Rm9yVHJhY2tCeSA9IChpbmRleCwgaXRlbSkgPT4ge1xuICAgICAqICAgICAgcmV0dXJuIGl0ZW0uaWQgKyBpdGVtLndpZHRoO1xuICAgICAqIH07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IGlneEZvclRyYWNrQnkoZm46IFRyYWNrQnlGdW5jdGlvbjxUPikgeyB0aGlzLl90cmFja0J5Rm4gPSBmbjsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCAmJiB0aGlzLmRjKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXdDb3B5ID0gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fZW1iZWRkZWRWaWV3cyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuc3RhdGUuY2h1bmtTaXplICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNudHggPSAoZW1iVmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55PikuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjbnR4LiRpbXBsaWNpdCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIGNudHguaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCk7XG4gICAgICAgICAgICAgICAgY250eC5jb3VudCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY01heEJyb3dzZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZGl2LnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLnRvcCA9ICc5OTk5OTk5OTk5OTk5OTk5cHgnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLmFicyhkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbJ3RvcCddKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSBjaHVua1NpemUgYmFzZWQgb24gY3VycmVudCBzdGFydEluZGV4IGFuZCByZXR1cm5zIHRoZSBuZXcgc2l6ZS5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5zdGF0ZS5zdGFydEluZGV4IGlzIHVwZGF0ZWQsIG5vdCBiZWZvcmUuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjdWxhdGVDaHVua1NpemUoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGNodW5rU2l6ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLmlneEZvckNvbnRhaW5lclNpemUgIT09IG51bGwgJiYgdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaXplc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuX2NhbGNNYXhDaHVua1NpemUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIGNodW5rU2l6ZSA+IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50KHZpZXdyZWYsIG5vZGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB2aWV3cmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIGVsZW0ubGVuZ3RoID4gMCA/IGVsZW1bMF0gOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFNpemVzQ2FjaGUoaXRlbXM6IGFueVtdKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIDogJ2hlaWdodCc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2goMCk7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sc1tpXVtkaW1lbnNpb25dID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGUucHVzaChzaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEl0ZW1TaXplKGl0ZW1zW2ldLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxTaXplICs9IHNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCh0b3RhbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbFNpemU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVTaXplQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHRDYWNoZS5sZW5ndGggPiAwID8gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIDogMDtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcblxuICAgICAgICBjb25zdCBkaWZmID0gb2xkSGVpZ2h0IC0gbmV3SGVpZ2h0O1xuXG4gICAgICAgIC8vIGlmIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCB3aGlsZSBjb250YWluZXIgaXMgc2Nyb2xsZWRcbiAgICAgICAgLy8gc2hvdWxkIHVwZGF0ZSBzY3JvbGwgdG9wL2xlZnQgYWNjb3JkaW5nIHRvIGNoYW5nZSBzbyB0aGF0IHNhbWUgc3RhcnRJbmRleCBpcyBpbiB2aWV3XG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCwgMTApO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIC0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY01heENodW5rU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgbWF4TGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGlmICghYXZhaWxhYmxlU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRJdGVtKSA9PiBhY2N1bXVsYXRvciArIHRoaXMuX2dldEl0ZW1TaXplKGN1cnJlbnRJdGVtLCBkaW1lbnNpb24pO1xuICAgICAgICBmb3IgKGk7IGkgPCB0aGlzLmlneEZvck9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB7IHZhbHVlOiB0aGlzLmlneEZvck9mW2ldLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0Q2FjaGVbaV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID9cbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodENhY2hlW2ldIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgc3VtID0gYXJyLnJlZHVjZShyZWR1Y2VyLCBzaXplKTtcbiAgICAgICAgICAgIGlmIChzdW0gPCBhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIHdpdGhvdXQgZXhjZWVkaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgcHJldiBpdGVtcyB1bnRpbCBzaXplIGlzIGZpbGxlZCBvciBmaXJzdCBpdGVtIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJJdGVtID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGFyclswXS52YWx1ZSA6IGFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZJbmRleCA9IHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihjdXJJdGVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2SW5kZXggPj0gMCAmJiBzdW0gPD0gYXZhaWxhYmxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VySXRlbSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyBhcnJbMF0udmFsdWUgOiBhcnJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSB0aGlzLmlneEZvck9mLmluZGV4T2YoY3VySXRlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkl0ZW0gPSB0aGlzLmlneEZvck9mW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGVbcHJldkluZGV4XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocHJldkl0ZW1bZGltZW5zaW9uXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gYXJyLnJlZHVjZShyZWR1Y2VyLCBwcmV2U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIudW5zaGlmdChwcmV2SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBhcnIuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heExlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEluZGV4QXQobGVmdCwgc2V0LCBpbmRleCkge1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gc2V0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBtaWRJZHggPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IG1pZExlZnQgPSBzZXRbbWlkSWR4XTtcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IGxlZnQgLSBtaWRMZWZ0O1xuICAgICAgICAgICAgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG1pZElkeCArIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBtaWRJZHggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkSWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9yZWNhbGNTY3JvbGxCYXJTaXplKCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogKHRoaXMuaWd4Rm9yT2YgPyB0aGlzLmlneEZvck9mLmxlbmd0aCA6IDApO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLm5vdFZpcnR1YWwgPSAhKHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAmJiB0aGlzLmRjICYmIHRoaXMuc3RhdGUuY2h1bmtTaXplIDwgY291bnQpO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlID0gdGhpcy5pc1Njcm9sbGFibGUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSA/IHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZikgOiAwO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gdG90YWxXaWR0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoIDw9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byByZXNldCB0aGUgc2Nyb2xsQW1vdW50IHZhbHVlIGhlcmUsIGJlY2F1c2UgaG9yaXpvbnRhbFNjcm9sbEJhciBpcyBoaWRkZW4sIHRoZXJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIG9uU2Nyb2xsIGV2ZW50IGhhbmRsZXIgZm9yIFZpcnR1YWxIZWxwZXJCYXNlRGlyZWN0aXZlIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRoaXMuX2NhbGNIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmICggdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA8PSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVzZXQgdGhlIHNjcm9sbEFtb3VudCB2YWx1ZSBoZXJlLCBiZWNhdXNlIHZlcnRpY2FsU2Nyb2xsQmFyIGlzIGhpZGRlbiwgdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gb25TY3JvbGwgZXZlbnQgaGFuZGxlciBmb3IgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsQW1vdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsYWJsZSAhPT0gdGhpcy5pc1Njcm9sbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gc2Nyb2xsYmFyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMub25TY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NhbGNIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0Q2FjaGUpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0Q2FjaGUucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlydEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaWYgKGhlaWdodCA+IHRoaXMuX21heEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fdmlydEhlaWdodFJhdGlvID0gaGVpZ2h0IC8gdGhpcy5fbWF4SGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fbWF4SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9yZWNhbGNPbkNvbnRhaW5lckNoYW5nZShjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIGNvbnN0IHByZXZDaHVua1NpemUgPSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5hcHBseUNodW5rU2l6ZUNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9yZWNhbGNTY3JvbGxCYXJTaXplKCk7XG4gICAgICAgIGlmIChwcmV2Q2h1bmtTaXplICE9PSB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpemVzQ2FjaGUgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGluZyBob3Jpem9udGFsIGNodW5rcyBhbmQgb2Zmc2V0cyBiYXNlZCBvbiB0aGUgbmV3IHNjcm9sbExlZnRcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLnNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbmV0IGZyb20gdGhlIGVtYmVkZGVkIHZpZXdzIGFuZCB1cGRhdGVzIGNodW5rU2l6ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTGFzdEVsZW0oKSB7XG4gICAgICAgIGNvbnN0IG9sZEVsZW0gPSB0aGlzLl9lbWJlZGRlZFZpZXdzLnBvcCgpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlVmlld0Rlc3Ryb3llZC5lbWl0KG9sZEVsZW0pO1xuICAgICAgICAvLyBhbHNvIGRldGFjaCBmcm9tIFZpZXdDb250YWluZXJSZWYgdG8gbWFrZSBhYnNvbHV0ZWx5IHN1cmUgdGhpcyBpcyByZW1vdmVkIGZyb20gdGhlIHZpZXcgY29udGFpbmVyLlxuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92Y3IuZGV0YWNoKHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5sZW5ndGggLSAxKTtcbiAgICAgICAgb2xkRWxlbS5kZXN0cm95KCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUtLTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogSWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgdGhhdCB3ZSBjYW4gY3JlYXRlIGVtYmVkZGVkIHZpZXcgZm9yIGNyZWF0ZXMgaXQsIGFwcGVuZHMgaXQgYW5kIHVwZGF0ZXMgY2h1bmtTaXplXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFkZExhc3RFbGVtKCkge1xuICAgICAgICBsZXQgZWxlbUluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1JbmRleCA+PSB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbUluZGV4ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbZWxlbUluZGV4XTtcbiAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3ID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICAgICAgbmV3IElneEZvck9mQ29udGV4dDxUPihpbnB1dCwgdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpLCB0aGlzLmlneEZvck9mLmxlbmd0aClcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9lbWJlZGRlZFZpZXdzLnB1c2goZW1iZWRkZWRWaWV3KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUrKztcblxuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGNodW5rU2l6ZSBhbmQgYWRkcy9yZW1vdmVzIGVsZW1lbnRzIGlmIG5lZWQgZHVlIHRvIHRoZSBjaGFuZ2UuXG4gICAgICogdGhpcy5zdGF0ZS5jaHVua1NpemUgaXMgdXBkYXRlZCBpbiBAYWRkTGFzdEVsZW0oKSBvciBAcmVtb3ZlTGFzdEVsZW0oKVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhcHBseUNodW5rU2l6ZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5pc1JlbW90ZSA/ICh0aGlzLmlneEZvck9mID8gdGhpcy5pZ3hGb3JPZi5sZW5ndGggOiAwKSA6IHRoaXMuX2NhbGN1bGF0ZUNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoY2h1bmtTaXplID4gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaHVua1NpemUgLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMYXN0RWxlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rU2l6ZSA8IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5zdGF0ZS5jaHVua1NpemUgLSBjaHVua1NpemU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGFzdEVsZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlU2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVIU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBfdXBkYXRlVlNjcm9sbE9mZnNldCgpIHtcbiAgICAgICAgbGV0IHNjcm9sbE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50U2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX3ZpcnRIZWlnaHRSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxUb3AodGhpcy5zY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgICBjdXJyZW50U2Nyb2xsVG9wID0gdGhpcy5fdmlydFNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2U2Nyb2xsID0gIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHNjcm9sbE9mZnNldCA9IHZTY3JvbGwgJiYgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA/XG4gICAgICAgIGN1cnJlbnRTY3JvbGxUb3AgLSB0aGlzLnNpemVzQ2FjaGVbdGhpcy5zdGF0ZS5zdGFydEluZGV4XSA6IDA7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jYWxjVmlydHVhbFNjcm9sbFRvcChzY3JvbGxUb3A6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IG1heFJlYWxTY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgY29uc3QgcmVhbFBlcmNlbnRTY3JvbGxlZCA9IG1heFJlYWxTY3JvbGxUb3AgIT09IDAgPyAgc2Nyb2xsVG9wIC8gbWF4UmVhbFNjcm9sbFRvcCA6IDA7XG4gICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0SGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgdGhpcy5fdmlydFNjcm9sbFRvcCA9IHJlYWxQZXJjZW50U2Nyb2xsZWQgKiBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3VwZGF0ZUhTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIGxldCBzY3JvbGxPZmZzZXQgPSAwO1xuICAgICAgICBzY3JvbGxPZmZzZXQgPSAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA/XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0gOiAwO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldCArICdweCc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0SXRlbVNpemUoaXRlbSwgZGltZW5zaW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkaW0gPSBpdGVtW2RpbWVuc2lvbl07XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGltID09PSAnbnVtYmVyJyA/IGRpbSA6IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKSB8fCAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGU6IGFueSk6IHN0cmluZyB7XG4gICAgY29uc3QgbmFtZSA9ICduYW1lJztcbiAgICByZXR1cm4gdHlwZVtuYW1lXSB8fCB0eXBlb2YgdHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRm9yT2ZTdGF0ZSBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBzdGFydEluZGV4PzogbnVtYmVyO1xuICAgIGNodW5rU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgY29udGFpbmVyU2l6ZTogbnVtYmVyO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hHcmlkRm9yXVtpZ3hHcmlkRm9yT2ZdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8VD4gZXh0ZW5kcyBJZ3hGb3JPZkRpcmVjdGl2ZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrIHtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4sXG4gICAgICAgIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIF96b25lOiBOZ1pvbmUsXG4gICAgICAgIHByb3RlY3RlZCBzeW5jU2Nyb2xsU2VydmljZTogSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIHN5bmNTZXJ2aWNlOiBJZ3hGb3JPZlN5bmNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUsIF9kaWZmZXJzLCByZXNvbHZlciwgY2RyLCBfem9uZSwgc3luY1Njcm9sbFNlcnZpY2UpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGlneEdyaWRGb3JPZih2YWx1ZSkge1xuICAgICAgICB0aGlzLmlneEZvck9mID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGlneEdyaWRGb3JPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWd4Rm9yT2Y7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIGJ1dCBiZWZvcmUgdGhlIHZpZXcgaXMgcmVmcmVzaGVkXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRGF0YUNoYW5naW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3M+KCk7XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGZvck9mID0gJ2lneEdyaWRGb3JPZic7XG4gICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMpO1xuICAgICAgICBpZiAoZm9yT2YgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzW2Zvck9mXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKHRoaXMuaWd4Rm9yVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgXCIke3ZhbHVlfVwiIG9mIHR5cGUgXCIke2dldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKX1cIi5cbiAgICAgICAgICAgICAgICAgICAgIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRJdGVtU2l6ZSA9ICdpZ3hGb3JJdGVtU2l6ZSc7XG4gICAgICAgIGlmIChkZWZhdWx0SXRlbVNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tkZWZhdWx0SXRlbVNpemVdLmZpcnN0Q2hhbmdlICYmXG4gICAgICAgICAgICAgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVmYXVsdCBpdGVtIHNpemUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9ICdpZ3hGb3JDb250YWluZXJTaXplJztcbiAgICAgICAgaWYgKGNvbnRhaW5lclNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tjb250YWluZXJTaXplXS5maXJzdENoYW5nZSAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNhbGNPbkNvbnRhaW5lckNoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNpemVzQ2FjaGUoKTogbnVtYmVyW10ge1xuICAgICAgICBpZiAodGhpcy5zeW5jU2VydmljZS5pc01hc3Rlcih0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVzQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc2l6ZXNDYWNoZSh2YWx1ZTogbnVtYmVyW10pIHtcbiAgICAgICAgdGhpcy5fc2l6ZXNDYWNoZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgaXRlbXNEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRJdGVtU2l6ZShpdGVtKSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIDogJ2hlaWdodCc7XG4gICAgICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnN1bW1hcmllcykge1xuICAgICAgICAgICAgICAgIHNpemUgPSBpdGVtLm1heDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmdyb3VwcyAmJiBpdGVtLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBpdGVtLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBwYXJzZUludChpdGVtW2RpbWVuc2lvbl0sIDEwKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpbml0U2l6ZXNDYWNoZShpdGVtczogYW55W10pOiBudW1iZXIge1xuICAgICAgICBpZiAoIXRoaXMuc3luY1NlcnZpY2UuaXNNYXN0ZXIodGhpcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hc3RlclNpemVzQ2FjaGUgPSB0aGlzLnN5bmNTZXJ2aWNlLnNpemVzQ2FjaGUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbWFzdGVyU2l6ZXNDYWNoZVttYXN0ZXJTaXplc0NhY2hlLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2goMCk7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmdldEl0ZW1TaXplKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zRGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGUucHVzaChzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2godG90YWxTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlU2l6ZUNhY2hlKGNoYW5nZXM6IEl0ZXJhYmxlQ2hhbmdlczxUPiA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0Q2FjaGUubGVuZ3RoID4gMCA/IHRoaXMuaGVpZ2h0Q2FjaGUucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKSA6IDA7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBvbGRIZWlnaHQ7XG4gICAgICAgIGlmIChjaGFuZ2VzICYmICF0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSB0aGlzLmhhbmRsZUNhY2hlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaWZmID0gb2xkSGVpZ2h0IC0gbmV3SGVpZ2h0O1xuXG4gICAgICAgIC8vIGlmIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCB3aGlsZSBjb250YWluZXIgaXMgc2Nyb2xsZWRcbiAgICAgICAgLy8gc2hvdWxkIHVwZGF0ZSBzY3JvbGwgdG9wL2xlZnQgYWNjb3JkaW5nIHRvIGNoYW5nZSBzbyB0aGF0IHNhbWUgc3RhcnRJbmRleCBpcyBpbiB2aWV3XG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgY29kZSBjYW4gYmUgcmVtb3ZlZC4gSG93ZXZlciB0ZXN0cyBuZWVkIHRvIGJlIHJld3JpdHRlbiBpbiBhIHdheSB0aGF0IHRoZXkgd2FpdCBmb3IgUmVzaXplT2JzZXJ2ZWQgdG8gY29tcGxldGUuXG4gICAgICAgICAgICAvLyBTbyBsZWF2aW5nIGFzIGlzIGZvciB0aGUgbW9tZW50LlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUG9zaXRpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUNhY2hlQ2hhbmdlcyhjaGFuZ2VzOiBJdGVyYWJsZUNoYW5nZXM8VD4pIHtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDaGFuZ2VzID0gW107XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodENhY2hlID0gW107XG4gICAgICAgIGNvbnN0IG5ld1NpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgbmV3U2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gMDtcblxuICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHJlbW92ZWQgaXRlbXMgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWxpYWJsZSBzbyB0aG9zZSB3aXRoIGlkZW50aXR5IGNoYW5nZSBzaG91bGQgYmUgZGVmYXVsdCBzaXplLlxuICAgICAgICBsZXQgbnVtUmVtb3ZlZEl0ZW1zID0gMDtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKCkgPT4gbnVtUmVtb3ZlZEl0ZW1zKyspO1xuXG4gICAgICAgIC8vIEdldCB0aGUgaWRlbnRpdHkgY2hhbmdlcyB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgdGhvc2UgdGhhdCBoYXZlIGNoYW5nZWQgdGhlaXIgaW5kZXhlcyBzaG91bGQgYmUgYXNzaWduZWQgZGVmYXVsdCBpdGVtIHNpemUuXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jdXJyZW50SW5kZXggIT09IGl0ZW0ucHJldmlvdXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgb25lcyB0aGF0IGhhdmUgbm90IGNoYW5nZWQgdGhlaXIgaW5kZXguXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb2Nlc3NpbmcgZWFjaCBpdGVtIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBpZ3hGb3JPZiBzbyBmYXIgc2VlbSB0byBiZSBtb3N0IHJlbGlhYmxlLiBXZSBwYXJzZSB0aGUgdXBkYXRlZCBsaXN0IG9mIGl0ZW1zLlxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJdGVtKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG51bVJlbW92ZWRJdGVtcyA8IDIgfHwgIWlkZW50aXR5Q2hhbmdlcy5sZW5ndGggfHwgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBjYWNoZSBvbiB0aG9zZSB3aG8gaGF2ZSBwcmV2aW91c0luZGV4LlxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcmVtb3ZlZCBpdGVtcyBjdXJyZW50bHkgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWFkYWJsZSBzbyBvbmVzIHdpdGggaWRlbnRpdHkgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJhY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gPSB0aGlzLmhlaWdodENhY2hlW2l0ZW0ucHJldmlvdXNJbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBkZWZhdWx0IGl0ZW0gc2l6ZS5cbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gPSB0aGlzLmdldEl0ZW1TaXplKGl0ZW0uaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaXplc0NhY2hlW2l0ZW0uY3VycmVudEluZGV4ICsgMV0gPSBuZXdTaXplc0NhY2hlW2l0ZW0uY3VycmVudEluZGV4XSArIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgIG5ld0hlaWdodCArPSBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhlaWdodENhY2hlID0gbmV3SGVpZ2h0Q2FjaGU7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IG5ld1NpemVzQ2FjaGU7XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3N1bWVNYXN0ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NpemVzQ2FjaGUgPSB0aGlzLnN5bmNTZXJ2aWNlLnNpemVzQ2FjaGUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclNpemU6IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFDaGFuZ2luZy5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vICByZS1pbml0IGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHdlIG5lZWQgdG8gcmVzZXQgdGhlIG1hc3RlciBkaXIgaWYgYWxsIHJvd3MgYXJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAoZS5nLiBiZWNhdXNlIG9mIGZpbHRlcmluZyk7IGlmIGFsbCBjb2x1bW5zIGFyZSBoaWRkZW4sIHJvd3MgYXJlXG4gICAgICAgICAgICAgICAgc3RpbGwgcmVuZGVyZWQgZW1wdHksIHNvIHdlIHNob3VsZCBub3QgcmVzZXQgbWFzdGVyICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NlcnZpY2UucmVzZXRNYXN0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JDb250YWluZXJTaXplID0gYXJncy5jb250YWluZXJTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpemVDYWNoZShjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YUNoYW5nZWQuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFwYXJzZUludCh0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmhlaWdodCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9iU2Nyb2xsSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNWaXJ0dWFsU2Nyb2xsVG9wKGV2ZW50LnRhcmdldC5zY3JvbGxUb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxUb3ApO1xuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG5cbiAgICAgICAgdGhpcy5fem9uZS5vblN0YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSggKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgb25IU2Nyb2xsKHNjcm9sbEFtb3VudCkge1xuICAgICAgICAvKiBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgdGhpcyBtYXkgYmUgY2FsbGVkIHdoZW4gbm8gc2Nyb2xsYmFyIGlzIHZpc2libGUgKi9cbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbXBvbmVudCB8fCAhcGFyc2VJbnQodGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRpbmcgaG9yaXpvbnRhbCBjaHVua3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHNjcm9sbEFtb3VudCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYWRkTGFzdEVsZW0oKSB7XG4gICAgICAgIGxldCBlbGVtSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbUluZGV4ID49IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltlbGVtSW5kZXhdO1xuICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICBuZXcgSWd4Rm9yT2ZDb250ZXh0PFQ+KGlucHV0LCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlVmlld3MocHJldkNodW5rU2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCAmJiB0aGlzLmRjKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXdDb3B5ID0gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fZW1iZWRkZWRWaWV3cyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNudHggPSAoZW1iVmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55PikuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjbnR4LiRpbXBsaWNpdCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIGNudHguaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCk7XG4gICAgICAgICAgICAgICAgY250eC5jb3VudCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBfYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaWV3cyhwcmV2Q2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2NhbGNNYXhDaHVua1NpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jU2VydmljZS5jaHVua1NpemUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hGb3JPZkRpcmVjdGl2ZSwgSWd4R3JpZEZvck9mRGlyZWN0aXZlLCBEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50LCBWaXJ0dWFsSGVscGVyQ29tcG9uZW50LFxuICAgICAgICAgSFZpcnR1YWxIZWxwZXJDb21wb25lbnQsIFZpcnR1YWxIZWxwZXJCYXNlRGlyZWN0aXZlXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50LCBWaXJ0dWFsSGVscGVyQ29tcG9uZW50LCBIVmlydHVhbEhlbHBlckNvbXBvbmVudF0sXG4gICAgZXhwb3J0czogW0lneEZvck9mRGlyZWN0aXZlLCBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtJZ3hTY3JvbGxJbmVydGlhTW9kdWxlLCBDb21tb25Nb2R1bGVdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4Rm9yT2ZNb2R1bGUge1xufVxuIl19