import { AfterViewInit, ElementRef, EventEmitter, OnInit, Renderer2, TemplateRef, OnDestroy, ChangeDetectorRef, OnChanges, NgZone, AfterContentInit } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { EditorProvider } from '../core/edit-provider';
import { Subject } from 'rxjs';
import { IRangeSliderValue, IgxSliderType, ISliderValueChangeEventArgs, TicksOrientation, TickLabelsOrientation } from './slider.common';
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './slider.common';
import * as ɵngcc2 from './thumb/thumb-slider.component';
import * as ɵngcc3 from './label/thumb-label.component';
import * as ɵngcc4 from './ticks/ticks.component';
import * as ɵngcc5 from './ticks/tick.pipe';
import * as ɵngcc6 from '@angular/common';
import * as ɵngcc7 from '@angular/forms';
export declare class IgxSliderComponent implements ControlValueAccessor, EditorProvider, OnInit, AfterViewInit, AfterContentInit, OnChanges, OnDestroy {
    private renderer;
    private _el;
    private _cdr;
    private _ngZone;
    private _pMin;
    private _pMax;
    private _hasViewInit;
    private _minValue;
    private _maxValue;
    private _lowerBound?;
    private _upperBound?;
    private _lowerValue?;
    private _upperValue?;
    private _continuous;
    private _disabled;
    private _step;
    private _value;
    private _primaryTicks;
    private _secondaryTicks;
    private _labels;
    private _type;
    private _destroyer$;
    private _indicatorsDestroyer$;
    private _indicatorsTimer;
    private _onChangeCallback;
    private _onTouchedCallback;
    /**
     * @hidden
     */
    private ticks;
    /**
     * @hidden
     */
    private thumbs;
    /**
     * @hidden
     */
    private labelRefs;
    private get thumbFrom();
    private get thumbTo();
    private get labelFrom();
    private get labelTo();
    /**
     * @hidden
     */
    trackRef: ElementRef;
    /**
     * @hidden
     */
    stepDistance: number;
    /**
     * @hidden
     */
    onPan: Subject<number>;
    /**
     * @hidden
     */
    thumbFromTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    thumbToTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    tickLabelTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    role: string;
    /**
     * @hidden
     */
    get valuemin(): number;
    /**
     * @hidden
     */
    get valuemax(): number;
    /**
     * @hidden
     */
    get readonly(): boolean;
    /**
     * @hidden
     */
    slierClass: boolean;
    /**
     * @hidden
     */
    get disabledClass(): boolean;
    /**
     * An @Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    id: string;
    /**
     * An @Input property that gets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     */
    get type(): IgxSliderType;
    /**
     * An @Input property that sets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * sliderType: IgxSliderType = IgxSliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     */
    set type(type: IgxSliderType);
    /**
     *An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     *```html
     *<igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     *```
     */
    thumbLabelVisibilityDuration: number;
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
     * This means that the manipulation for those properties won't be allowed.
     */
    get labels(): Array<number | string | boolean | null | undefined>;
    set labels(labels: Array<number | string | boolean | null | undefined>);
    /**
     * Returns the template context corresponding
     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
     *
     * ```typescript
     * return {
     *  $implicit // returns the value of the label,
     *  labels // returns the labels collection the user has passed.
     * }
     * ```
     */
    get context(): any;
    /**
     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    set step(step: number);
    /**
     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     */
    get step(): number;
    /**
     * Returns if the {@link IgxSliderComponent} is disabled.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     */
    get disabled(): boolean;
    /**
     *An @Input property that disables or enables UI interaction.
     *```html
     *<igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     *```
     */
    set disabled(disable: boolean);
    /**
     * Returns if the {@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     */
    get continuous(): boolean;
    /**
     * An @Input property that marks the {@link IgxSliderComponent} as continuous.
     * By default is considered that the {@link IgxSliderComponent} is discrete.
     * Discrete {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set continuous(continuous: boolean);
    /**
     *Returns the minimal value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderMin = this.slider.minValue;
     *}
     *```
     */
    get minValue(): number;
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     */
    set minValue(value: number);
    /**
 * Returns the maximum value for the {@link IgxSliderComponent}.
 * ```typescript
 *@ViewChild("slider")
 *public slider: IgxSliderComponent;
 *ngAfterViewInit(){
 *    let sliderMax = this.slider.maxValue;
 *}
 * ```
 */
    get maxValue(): number;
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     */
    set maxValue(value: number);
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderLowBound = this.slider.lowerBound;
     *}
     *```
     */
    get lowerBound(): number;
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     */
    set lowerBound(value: number);
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     *}
     * ```
     */
    get upperBound(): number;
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     */
    set upperBound(value: number);
    /**
     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
     * If the slider type is {@link IgxSliderType.RANGE}.
     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public sliderValue(event){
     *    let sliderVal = this.slider.value;
     *}
     *```
     */
    get value(): number | IRangeSliderValue;
    /**
     * Sets the slider value.
     * If the slider is of type {@link IgxSliderType.SLIDER}.
     * The argument is number. By default the {@link value} gets the {@link lowerBound}.
     * If the slider type is {@link IgxSliderType.RANGE} the argument
     * represents an object of {@link lowerValue} and {@link upperValue} properties.
     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
     * ```typescript
     *rangeValue = {
     *   lower: 30,
     *   upper: 60
     *};
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     */
    set value(value: number | IRangeSliderValue);
    /**
     * Returns the number of the presented primary ticks.
     * ```typescript
     * const primaryTicks = this.slider.primaryTicks;
     * ```
     */
    get primaryTicks(): number;
    /**
     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
     * Insted enable ticks by {@link showTicks} property.
     * ```typescript
     * this.slider.primaryTicks = 5;
     * ```
     */
    set primaryTicks(val: number);
    /**
     * Returns the number of the presented secondary ticks.
     * ```typescript
     * const secondaryTicks = this.slider.secondaryTicks;
     * ```
     */
    get secondaryTicks(): number;
    /**
     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
     * but all secondary ticks won't present any tick labels.
     * ```typescript
     * this.slider.secondaryTicks = 5;
     * ```
     */
    set secondaryTicks(val: number);
    /**
     * Show/hide slider ticks
     * ```html
     * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
     * ```
     */
    showTicks: boolean;
    /**
     * show/hide primary tick labels
     * ```html
     * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
     * ```
     */
    primaryTickLabels: boolean;
    /**
     * show/hide secondary tick labels
     * ```html
     * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
     * ```
     */
    secondaryTickLabels: boolean;
    /**
     * Changes ticks orientation:
     * bottom - The default orienation, below the slider track.
     * top - Above the slider track
     * mirror - combines top and bottom orientation.
     * ```html
     * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
     * ```
     */
    ticksOrientation: TicksOrientation;
    /**
     * Changes tick labels rotation:
     * horizontal - The default rotation
     * toptobottom - Rotates tick labels vertically to 90deg
     * bottomtotop - Rotate tick labels vertically to -90deg
     * ```html
     * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
     * ```
     */
    tickLabelsOrientation: TickLabelsOrientation;
    /**
     * @hidden
     */
    get deactivateThumbLabel(): boolean;
    /**
     * This event is emitted every time the value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     *}
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    onValueChange: EventEmitter<ISliderValueChangeEventArgs>;
    /**
     * This event is emitted at the end of every slide interaction.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     *}
     * ```
     * ```html
     * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    onValueChanged: EventEmitter<number | IRangeSliderValue>;
    constructor(renderer: Renderer2, _el: ElementRef, _cdr: ChangeDetectorRef, _ngZone: NgZone);
    /**
     * @hidden
     */
    onPointerDown($event: PointerEvent): void;
    /**
     * @hidden
     */
    onPointerUp($event: PointerEvent): void;
    /**
     * @hidden
     */
    onFocus(): void;
    /**
     * @hidden
     */
    onPanListener($event: any): void;
    /**
     *Returns whether the `IgxSliderComponent` type is RANGE.
     *```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderRange = this.slider.isRange;
     *}
     * ```
     */
    get isRange(): boolean;
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     *}
     *```
     */
    get lowerValue(): number;
    /**
     *Sets the lower value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public lowValue(event){
     *    this.slider.lowerValue = 120;
     *}
     *```
     */
    set lowerValue(value: number);
    /**
     *Returns the upper value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public upperValue(event){
     *    let upperValue = this.slider.upperValue;
     *}
     *```
     */
    get upperValue(): number;
    /**
     *Sets the upper value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public upperValue(event){
     *    this.slider.upperValue = 120;
     *}
     *```
     */
    set upperValue(value: number);
    /**
     * Returns the value corresponding the lower label.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     *```
     */
    get lowerLabel(): string | number | boolean;
    /**
     * Returns the value corresponding the upper label.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     *```
     */
    get upperLabel(): string | number | boolean;
    /**
     * Returns if label view is enabled.
     * If the {@link labels} is set, the view is automatically activated.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     *```
     */
    get labelsViewEnabled(): boolean;
    /**
     * @hidden
     */
    get showTopTicks(): boolean;
    /**
     * @hidden
     */
    get showBottomTicks(): boolean;
    /**
     * @hidden
     */
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    writeValue(value: IRangeSliderValue | number): void;
    /**
     * @hidden
     */
    registerOnChange(fn: any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: any): void;
    /** @hidden */
    getEditElement(): any;
    /**
     *
     * @hidden
     */
    update(mouseX: any): void;
    /**
     * @hidden
     */
    thumbChanged(value: number, thumbType: number): void;
    /**
     * @hidden
     */
    onThumbChange(): void;
    /**
     * @hidden
     */
    onHoverChange(state: boolean): void;
    private swapThumb;
    private findClosestThumb;
    private updateLowerBoundAndMinTravelZone;
    private updateUpperBoundAndMaxTravelZone;
    private sliderSetup;
    private calculateStepDistance;
    private toggleThumb;
    private valueInRange;
    private generateTickMarks;
    private positionHandler;
    private positionHandlersAndUpdateTrack;
    private closestHandle;
    private setTickInterval;
    private showSliderIndicators;
    private hideSliderIndicators;
    private toggleSliderIndicators;
    private changeThumbFocusableState;
    private closestTo;
    private valueToFraction;
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {@link this.step} is set.
     * @param value
     */
    private normalizeByStep;
    private updateTrack;
    private validateInitialValue;
    private subscribeTo;
    private unsubscriber;
    private hasValueChanged;
    setValue(value: number | IRangeSliderValue): void;
    private emitValueChanged;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxSliderComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxSliderComponent, "igx-slider", never, { "id": "id"; "thumbLabelVisibilityDuration": "thumbLabelVisibilityDuration"; "showTicks": "showTicks"; "primaryTickLabels": "primaryTickLabels"; "secondaryTickLabels": "secondaryTickLabels"; "ticksOrientation": "ticksOrientation"; "tickLabelsOrientation": "tickLabelsOrientation"; "type": "type"; "labels": "labels"; "step": "step"; "disabled": "disabled"; "continuous": "continuous"; "minValue": "minValue"; "lowerBound": "lowerBound"; "maxValue": "maxValue"; "upperBound": "upperBound"; "value": "value"; "primaryTicks": "primaryTicks"; "secondaryTicks": "secondaryTicks"; }, { "onValueChange": "onValueChange"; "onValueChanged": "onValueChanged"; }, ["thumbFromTemplateRef", "thumbToTemplateRef", "tickLabelTemplateRef"], never>;
}
/**
 * @hidden
 */
export declare class IgxSliderModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxSliderModule, [typeof IgxSliderComponent, typeof ɵngcc1.IgxThumbFromTemplateDirective, typeof ɵngcc1.IgxThumbToTemplateDirective, typeof ɵngcc1.IgxTickLabelTemplateDirective, typeof ɵngcc2.IgxSliderThumbComponent, typeof ɵngcc3.IgxThumbLabelComponent, typeof ɵngcc4.IgxTicksComponent, typeof ɵngcc5.IgxTickLabelsPipe], [typeof ɵngcc6.CommonModule, typeof ɵngcc7.FormsModule], [typeof IgxSliderComponent, typeof ɵngcc1.IgxThumbFromTemplateDirective, typeof ɵngcc1.IgxThumbToTemplateDirective, typeof ɵngcc1.IgxTickLabelTemplateDirective, typeof ɵngcc2.IgxSliderThumbComponent, typeof ɵngcc3.IgxThumbLabelComponent, typeof ɵngcc4.IgxTicksComponent]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxSliderModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJzbGlkZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiwgT25DaGFuZ2VzLCBOZ1pvbmUsIEFmdGVyQ29udGVudEluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRWRpdG9yUHJvdmlkZXIgfSBmcm9tICcuLi9jb3JlL2VkaXQtcHJvdmlkZXInO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVJhbmdlU2xpZGVyVmFsdWUsIElneFNsaWRlclR5cGUsIElTbGlkZXJWYWx1ZUNoYW5nZUV2ZW50QXJncywgVGlja3NPcmllbnRhdGlvbiwgVGlja0xhYmVsc09yaWVudGF0aW9uIH0gZnJvbSAnLi9zbGlkZXIuY29tbW9uJztcbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgU2xpZGVyKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL3NsaWRlci5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgU2xpZGVyIGFsbG93cyBzZWxlY3Rpb24gaW4gYSBnaXZlbiByYW5nZSBieSBtb3ZpbmcgdGhlIHRodW1iIGFsb25nIHRoZSB0cmFjay4gVGhlIHRyYWNrXG4gKiBjYW4gYmUgZGVmaW5lZCBhcyBjb250aW51b3VzIG9yIHN0ZXBwZWQsIGFuZCB5b3UgY2FuIGNob29zZSBiZXR3ZWVuIHNpbmdsZSBhbmQgcmFuZ2Ugc2xpZGVyIHR5cGVzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LXNsaWRlciBpZD1cInNsaWRlclwiXG4gKiAgICAgICAgICAgIFttaW5WYWx1ZV09XCIwXCIgW21heFZhbHVlXT1cIjEwMFwiXG4gKiAgICAgICAgICAgIFtjb250aW51b3VzXT10cnVlIFsobmdNb2RlbCldPVwidm9sdW1lXCI+XG4gKiA8L2lneC1zbGlkZXI+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4U2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEVkaXRvclByb3ZpZGVyLCBPbkluaXQsIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgX2VsO1xuICAgIHByaXZhdGUgX2NkcjtcbiAgICBwcml2YXRlIF9uZ1pvbmU7XG4gICAgcHJpdmF0ZSBfcE1pbjtcbiAgICBwcml2YXRlIF9wTWF4O1xuICAgIHByaXZhdGUgX2hhc1ZpZXdJbml0O1xuICAgIHByaXZhdGUgX21pblZhbHVlO1xuICAgIHByaXZhdGUgX21heFZhbHVlO1xuICAgIHByaXZhdGUgX2xvd2VyQm91bmQ/O1xuICAgIHByaXZhdGUgX3VwcGVyQm91bmQ/O1xuICAgIHByaXZhdGUgX2xvd2VyVmFsdWU/O1xuICAgIHByaXZhdGUgX3VwcGVyVmFsdWU/O1xuICAgIHByaXZhdGUgX2NvbnRpbnVvdXM7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQ7XG4gICAgcHJpdmF0ZSBfc3RlcDtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIF9wcmltYXJ5VGlja3M7XG4gICAgcHJpdmF0ZSBfc2Vjb25kYXJ5VGlja3M7XG4gICAgcHJpdmF0ZSBfbGFiZWxzO1xuICAgIHByaXZhdGUgX3R5cGU7XG4gICAgcHJpdmF0ZSBfZGVzdHJveWVyJDtcbiAgICBwcml2YXRlIF9pbmRpY2F0b3JzRGVzdHJveWVyJDtcbiAgICBwcml2YXRlIF9pbmRpY2F0b3JzVGltZXI7XG4gICAgcHJpdmF0ZSBfb25DaGFuZ2VDYWxsYmFjaztcbiAgICBwcml2YXRlIF9vblRvdWNoZWRDYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSB0aWNrcztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSB0aHVtYnM7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgbGFiZWxSZWZzO1xuICAgIHByaXZhdGUgZ2V0IHRodW1iRnJvbSgpO1xuICAgIHByaXZhdGUgZ2V0IHRodW1iVG8oKTtcbiAgICBwcml2YXRlIGdldCBsYWJlbEZyb20oKTtcbiAgICBwcml2YXRlIGdldCBsYWJlbFRvKCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRyYWNrUmVmOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzdGVwRGlzdGFuY2U6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25QYW46IFN1YmplY3Q8bnVtYmVyPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGh1bWJGcm9tVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRodW1iVG9UZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGlja0xhYmVsVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJvbGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlbWluKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlbWF4KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlYWRvbmx5KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNsaWVyQ2xhc3M6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZENsYXNzKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbaWRdPVwiJ2lneC1zbGlkZXItMzInXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGdldHMgdGhlIHR5cGUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIFRoZSBzbGlkZXIgY2FuIGJlIElneFNsaWRlclR5cGUuU0xJREVSKGRlZmF1bHQpIG9yIElneFNsaWRlclR5cGUuUkFOR0UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgdHlwZSA9IHRoaXMuc2xpZGVyLnR5cGU7XG4gICAgICogfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCk6IElneFNsaWRlclR5cGU7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdHlwZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIHNsaWRlciBjYW4gYmUgSWd4U2xpZGVyVHlwZS5TTElERVIoZGVmYXVsdCkgb3IgSWd4U2xpZGVyVHlwZS5SQU5HRS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc2xpZGVyVHlwZTogSWd4U2xpZGVyVHlwZSA9IElneFNsaWRlclR5cGUuUkFOR0U7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiMFwiIFttYXhWYWx1ZV09XCIxMDBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgdHlwZSh0eXBlOiBJZ3hTbGlkZXJUeXBlKTtcbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGR1cmF0aW9uIHZpc2liaWxpdHkgb2YgdGh1bWJzIGxhYmVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNzUwIG1pbGxpc2Vjb25kcy5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtc2xpZGVyICNzbGlkZXIgW3RodW1iTGFiZWxWaXNpYmlsaXR5RHVyYXRpb25dPVwiMzAwMFwiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgdGh1bWJMYWJlbFZpc2liaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYGxhYmVsVmlld2AsIGJ5IGFjY2VwdGluZyBhIGNvbGxlY3Rpb24gb2YgcHJpbWl0aXZlIHZhbHVlcyB3aXRoIG1vcmUgdGhhbiBvbmUgZWxlbWVudC5cbiAgICAgKiBFYWNoIGVsZW1lbnQgd2lsbCBiZSBlcXVhbGx5IHNwcmVhZCBvdmVyIHRoZSBzbGlkZXIgYW5kIGl0IHdpbGwgc2VydmUgYXMgYSB0aHVtYiBsYWJlbC5cbiAgICAgKiBPbmNlIHRoZSBwcm9wZXJ0eSBpcyBzZXQsIGl0IHdpbGwgcHJlY2VuZGVuY2Ugb3ZlciB7QGxpbmsgbWF4VmFsdWV9LCB7QGxpbmsgbWluVmFsdWV9LCB7QGxpbmsgc3RlcH0uXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHRoZSBtYW5pcHVsYXRpb24gZm9yIHRob3NlIHByb3BlcnRpZXMgd29uJ3QgYmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgbGFiZWxzKCk6IEFycmF5PG51bWJlciB8IHN0cmluZyB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgICBzZXQgbGFiZWxzKGxhYmVsczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ+KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBjb250ZXh0IGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0byB7QGxpbmsgSWd4VGh1bWJGcm9tVGVtcGxhdGVEaXJlY3RpdmV9IGFuZCB7QGxpbmsgSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlfSB0ZW1wbGF0ZXMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcmV0dXJuIHtcbiAgICAgKiAgJGltcGxpY2l0IC8vIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBsYWJlbCxcbiAgICAgKiAgbGFiZWxzIC8vIHJldHVybnMgdGhlIGxhYmVscyBjb2xsZWN0aW9uIHRoZSB1c2VyIGhhcyBwYXNzZWQuXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb250ZXh0KCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBpbmNyZW1lbnRhbC9kZWNyZW1lbnRhbCBzdGVwIG9mIHRoZSB2YWx1ZSB3aGVuIGRyYWdnaW5nIHRoZSB0aHVtYi5cbiAgICAgKiBUaGUgZGVmYXVsdCBzdGVwIGlzIDEsIGFuZCBzdGVwIHNob3VsZCBub3QgYmUgbGVzcyBvciBlcXVhbCB0aGFuIDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHN0ZXAoc3RlcDogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmNyZW1lbnRhbC9kZWNyZW1lbnRhbCBkcmFnZ2luZyBzdGVwIG9mIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5zbGlkZXIuc3RlcDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHN0ZXAoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGlzRGlzYWJsZWQgPSB0aGlzLnNsaWRlci5kaXNhYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBkaXNhYmxlcyBvciBlbmFibGVzIFVJIGludGVyYWN0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1zbGlkZXIgI3NsaWRlciBbZGlzYWJsZWRdPVwiJ3RydWUnXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlZChkaXNhYmxlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBzZXQgYXMgY29udGludW91cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBjb250aW51b3VzID0gdGhpcy5zbGlkZXIuY29udGludW91cztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvbnRpbnVvdXMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBtYXJrcyB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gYXMgY29udGludW91cy5cbiAgICAgKiBCeSBkZWZhdWx0IGlzIGNvbnNpZGVyZWQgdGhhdCB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gaXMgZGlzY3JldGUuXG4gICAgICogRGlzY3JldGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gZG9lcyBub3QgaGF2ZSB0aWNrcyBhbmQgZG9lcyBub3Qgc2hvdyBidWJibGUgbGFiZWxzIGZvciB2YWx1ZXMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIgW2NvbnRpbnVvdXNdPVwiJ3RydWUnXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgY29udGludW91cyhjb250aW51b3VzOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIG1pbmltYWwgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJNaW4gPSB0aGlzLnNsaWRlci5taW5WYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBtaW5WYWx1ZSgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWluaW1hbCB2YWx1ZSBmb3IgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIFRoZSBkZWZhdWx0IG1pbmltYWwgdmFsdWUgaXMgMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIxMDBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgbWluVmFsdWUodmFsdWU6IG51bWJlcik7XG4gICAgLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0uXG4gKiBgYGB0eXBlc2NyaXB0XG4gKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICpuZ0FmdGVyVmlld0luaXQoKXtcbiAqICAgIGxldCBzbGlkZXJNYXggPSB0aGlzLnNsaWRlci5tYXhWYWx1ZTtcbiAqfVxuICogYGBgXG4gKi9cbiAgICBnZXQgbWF4VmFsdWUoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1heGltYWwgdmFsdWUgZm9yIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBUaGUgZGVmYXVsdCBtYXhpbXVtIHZhbHVlIGlzIDEwMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIyNTZcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgbWF4VmFsdWUodmFsdWU6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlckxvd0JvdW5kID0gdGhpcy5zbGlkZXIubG93ZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBsb3dlckJvdW5kKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogSWYgbm90IHNldCBpcyB0aGUgc2FtZSBhcyBtaW4gdmFsdWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBsb3dlckJvdW5kKHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyVXBCb3VuZCA9IHRoaXMuc2xpZGVyLnVwcGVyQm91bmQ7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHVwcGVyQm91bmQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBJZiBub3Qgc2V0IGlzIHRoZSBzYW1lIGFzIG1heCB2YWx1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3N0ZXBdPVwiNVwiIFt1cHBlckJvdW5kXT1cIjIwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHVwcGVyQm91bmQodmFsdWU6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2xpZGVyIHZhbHVlLiBJZiB0aGUgc2xpZGVyIGlzIG9mIHR5cGUge0BsaW5rIElneFNsaWRlclR5cGUuU0xJREVSfSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVtYmVyLlxuICAgICAqIElmIHRoZSBzbGlkZXIgdHlwZSBpcyB7QGxpbmsgSWd4U2xpZGVyVHlwZS5SQU5HRX0uXG4gICAgICogVGhlIHJldHVybmVkIHZhbHVlIHJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHtAbGluayBsb3dlclZhbHVlfSBhbmQge0BsaW5rIHVwcGVyVmFsdWV9LlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzbGlkZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHNsaWRlclZhbCA9IHRoaXMuc2xpZGVyLnZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIGlzIG9mIHR5cGUge0BsaW5rIElneFNsaWRlclR5cGUuU0xJREVSfS5cbiAgICAgKiBUaGUgYXJndW1lbnQgaXMgbnVtYmVyLiBCeSBkZWZhdWx0IHRoZSB7QGxpbmsgdmFsdWV9IGdldHMgdGhlIHtAbGluayBsb3dlckJvdW5kfS5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIHR5cGUgaXMge0BsaW5rIElneFNsaWRlclR5cGUuUkFOR0V9IHRoZSBhcmd1bWVudFxuICAgICAqIHJlcHJlc2VudHMgYW4gb2JqZWN0IG9mIHtAbGluayBsb3dlclZhbHVlfSBhbmQge0BsaW5rIHVwcGVyVmFsdWV9IHByb3BlcnRpZXMuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgb2JqZWN0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUge0BsaW5rIGxvd2VyQm91bmR9IGFuZCB7QGxpbmsgdXBwZXJCb3VuZH0gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKnJhbmdlVmFsdWUgPSB7XG4gICAgICogICBsb3dlcjogMzAsXG4gICAgICogICB1cHBlcjogNjBcbiAgICAgKn07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMjU2XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSBwcmVzZW50ZWQgcHJpbWFyeSB0aWNrcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcHJpbWFyeVRpY2tzID0gdGhpcy5zbGlkZXIucHJpbWFyeVRpY2tzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBwcmltYXJ5VGlja3MoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwcmltYXJ5IHRpY2tzLiBJZiB7QGxpbmsgQGxhYmVsc30gaXMgZW5hYmxlZCwgdGhpcyBwcm9wZXJ0eSB3b24ndCBmdW5jdGlvbi5cbiAgICAgKiBJbnN0ZWQgZW5hYmxlIHRpY2tzIGJ5IHtAbGluayBzaG93VGlja3N9IHByb3BlcnR5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnNsaWRlci5wcmltYXJ5VGlja3MgPSA1O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBwcmltYXJ5VGlja3ModmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgcHJlc2VudGVkIHNlY29uZGFyeSB0aWNrcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2Vjb25kYXJ5VGlja3MgPSB0aGlzLnNsaWRlci5zZWNvbmRhcnlUaWNrcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgc2Vjb25kYXJ5VGlja3MoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBzZWNvbmRhcnkgdGlja3MuIFRoZSBwcm9wZXJ0eSBmdW5jdGlvbnMgZXZlbiB3aGVuIHtAbGluayBsYWJlbHN9IGlzIGVuYWJsZWQsXG4gICAgICogYnV0IGFsbCBzZWNvbmRhcnkgdGlja3Mgd29uJ3QgcHJlc2VudCBhbnkgdGljayBsYWJlbHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc2xpZGVyLnNlY29uZGFyeVRpY2tzID0gNTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgc2Vjb25kYXJ5VGlja3ModmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFNob3cvaGlkZSBzbGlkZXIgdGlja3NcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGllciBbc2hvd1RpY2tzXT1cInRydWVcIiBbcHJpbWFyeVRpY2tzXT1cIjVcIj48L2lneC1zbGllcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzaG93VGlja3M6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogc2hvdy9oaWRlIHByaW1hcnkgdGljayBsYWJlbHNcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3ByaW1hcnlUaWNrc109XCI1XCIgW3ByaW1hcnlUaWNrTGFiZWxzXT1cImZhbHNlXCI+PC9pZ3gtc2xpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHByaW1hcnlUaWNrTGFiZWxzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIHNob3cvaGlkZSBzZWNvbmRhcnkgdGljayBsYWJlbHNcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3NlY29uZGFyeVRpY2tzXT1cIjVcIiBbc2Vjb25kYXJ5VGlja0xhYmVsc109XCJmYWxzZVwiPjwvaWd4LXNsaWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZWNvbmRhcnlUaWNrTGFiZWxzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGlja3Mgb3JpZW50YXRpb246XG4gICAgICogYm90dG9tIC0gVGhlIGRlZmF1bHQgb3JpZW5hdGlvbiwgYmVsb3cgdGhlIHNsaWRlciB0cmFjay5cbiAgICAgKiB0b3AgLSBBYm92ZSB0aGUgc2xpZGVyIHRyYWNrXG4gICAgICogbWlycm9yIC0gY29tYmluZXMgdG9wIGFuZCBib3R0b20gb3JpZW50YXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtwcmltYXJ5VGlja3NdPVwiNVwiIFt0aWNrc09yaWVudGF0aW9uXT1cInRpY2tzT3JpZW50YXRpb25cIj48L2lneC1zbGlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGlja3NPcmllbnRhdGlvbjogVGlja3NPcmllbnRhdGlvbjtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRpY2sgbGFiZWxzIHJvdGF0aW9uOlxuICAgICAqIGhvcml6b250YWwgLSBUaGUgZGVmYXVsdCByb3RhdGlvblxuICAgICAqIHRvcHRvYm90dG9tIC0gUm90YXRlcyB0aWNrIGxhYmVscyB2ZXJ0aWNhbGx5IHRvIDkwZGVnXG4gICAgICogYm90dG9tdG90b3AgLSBSb3RhdGUgdGljayBsYWJlbHMgdmVydGljYWxseSB0byAtOTBkZWdcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3ByaW1hcnlUaWNrc109XCI1XCIgW3NlY29uZGFyeVRpY2tzXT1cIjNcIiBbdGlja0xhYmVsc09yaWVudGF0aW9uXT1cInRpY2tMYWJlbHNPcmllbnRhaXRvblwiPjwvaWd4LXNsaWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aWNrTGFiZWxzT3JpZW50YXRpb246IFRpY2tMYWJlbHNPcmllbnRhdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRlYWN0aXZhdGVUaHVtYkxhYmVsKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBjaGFuZ2UoZXZlbnQpe1xuICAgICAqICAgIGFsZXJ0KFwiVGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQhXCIpO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciAob25WYWx1ZUNoYW5nZSk9XCJjaGFuZ2UoJGV2ZW50KVwiICNzbGlkZXIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25WYWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPElTbGlkZXJWYWx1ZUNoYW5nZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgc2xpZGUgaW50ZXJhY3Rpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBjaGFuZ2UoZXZlbnQpe1xuICAgICAqICAgIGFsZXJ0KFwiVGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQhXCIpO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciAob25WYWx1ZUNoYW5nZWQpPVwiY2hhbmdlKCRldmVudClcIiAjc2xpZGVyIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uVmFsdWVDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWU+O1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBSZW5kZXJlcjIsIF9lbDogRWxlbWVudFJlZiwgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9uZ1pvbmU6IE5nWm9uZSk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUG9pbnRlckRvd24oJGV2ZW50OiBQb2ludGVyRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblBvaW50ZXJVcCgkZXZlbnQ6IFBvaW50ZXJFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRm9jdXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25QYW5MaXN0ZW5lcigkZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHdoZXRoZXIgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgIHR5cGUgaXMgUkFOR0UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyUmFuZ2UgPSB0aGlzLnNsaWRlci5pc1JhbmdlO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBpc1JhbmdlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBsb3dWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHNsaWRlckxvd1ZhbHVlID0gdGhpcy5zbGlkZXIubG93ZXJWYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBsb3dlclZhbHVlKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldHMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgbG93VmFsdWUoZXZlbnQpe1xuICAgICAqICAgIHRoaXMuc2xpZGVyLmxvd2VyVmFsdWUgPSAxMjA7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgbG93ZXJWYWx1ZSh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgdXBwZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHVwcGVyVmFsdWUgPSB0aGlzLnNsaWRlci51cHBlclZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IHVwcGVyVmFsdWUoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdXBwZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyB1cHBlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICB0aGlzLnNsaWRlci51cHBlclZhbHVlID0gMTIwO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHVwcGVyVmFsdWUodmFsdWU6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0aGUgbG93ZXIgbGFiZWwuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBsZXQgbGFiZWwgPSB0aGlzLnNsaWRlci5sb3dlckxhYmVsO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGxvd2VyTGFiZWwoKTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRoZSB1cHBlciBsYWJlbC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIGxldCBsYWJlbCA9IHRoaXMuc2xpZGVyLnVwcGVyTGFiZWw7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgdXBwZXJMYWJlbCgpOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgbGFiZWwgdmlldyBpcyBlbmFibGVkLlxuICAgICAqIElmIHRoZSB7QGxpbmsgbGFiZWxzfSBpcyBzZXQsIHRoZSB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgYWN0aXZhdGVkLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbGV0IGxhYmVsVmlldyA9IHRoaXMuc2xpZGVyLmxhYmVsc1ZpZXdFbmFibGVkO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGxhYmVsc1ZpZXdFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzaG93VG9wVGlja3MoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHNob3dCb3R0b21UaWNrcygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IGFueSk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBJUmFuZ2VTbGlkZXJWYWx1ZSB8IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZ2V0RWRpdEVsZW1lbnQoKTogYW55O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVwZGF0ZShtb3VzZVg6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHRodW1iQ2hhbmdlZCh2YWx1ZTogbnVtYmVyLCB0aHVtYlR5cGU6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uVGh1bWJDaGFuZ2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Ib3ZlckNoYW5nZShzdGF0ZTogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHJpdmF0ZSBzd2FwVGh1bWI7XG4gICAgcHJpdmF0ZSBmaW5kQ2xvc2VzdFRodW1iO1xuICAgIHByaXZhdGUgdXBkYXRlTG93ZXJCb3VuZEFuZE1pblRyYXZlbFpvbmU7XG4gICAgcHJpdmF0ZSB1cGRhdGVVcHBlckJvdW5kQW5kTWF4VHJhdmVsWm9uZTtcbiAgICBwcml2YXRlIHNsaWRlclNldHVwO1xuICAgIHByaXZhdGUgY2FsY3VsYXRlU3RlcERpc3RhbmNlO1xuICAgIHByaXZhdGUgdG9nZ2xlVGh1bWI7XG4gICAgcHJpdmF0ZSB2YWx1ZUluUmFuZ2U7XG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVRpY2tNYXJrcztcbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlcjtcbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlcnNBbmRVcGRhdGVUcmFjaztcbiAgICBwcml2YXRlIGNsb3Nlc3RIYW5kbGU7XG4gICAgcHJpdmF0ZSBzZXRUaWNrSW50ZXJ2YWw7XG4gICAgcHJpdmF0ZSBzaG93U2xpZGVySW5kaWNhdG9ycztcbiAgICBwcml2YXRlIGhpZGVTbGlkZXJJbmRpY2F0b3JzO1xuICAgIHByaXZhdGUgdG9nZ2xlU2xpZGVySW5kaWNhdG9ycztcbiAgICBwcml2YXRlIGNoYW5nZVRodW1iRm9jdXNhYmxlU3RhdGU7XG4gICAgcHJpdmF0ZSBjbG9zZXN0VG87XG4gICAgcHJpdmF0ZSB2YWx1ZVRvRnJhY3Rpb247XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE5vcm1hbGl60LUgdGhlIHZhbHVlIHdoZW4gdHdvLXdheSBkYXRhIGJpbmQgaXMgdXNlZCBhbmQge0BsaW5rIHRoaXMuc3RlcH0gaXMgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHByaXZhdGUgbm9ybWFsaXplQnlTdGVwO1xuICAgIHByaXZhdGUgdXBkYXRlVHJhY2s7XG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUluaXRpYWxWYWx1ZTtcbiAgICBwcml2YXRlIHN1YnNjcmliZVRvO1xuICAgIHByaXZhdGUgdW5zdWJzY3JpYmVyO1xuICAgIHByaXZhdGUgaGFzVmFsdWVDaGFuZ2VkO1xuICAgIHNldFZhbHVlKHZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBlbWl0VmFsdWVDaGFuZ2VkO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFNsaWRlck1vZHVsZSB7XG59XG4iXX0=