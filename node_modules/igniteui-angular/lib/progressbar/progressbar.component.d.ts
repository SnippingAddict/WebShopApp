import { EventEmitter, Renderer2, AfterViewInit } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective } from './progressbar.common';
import { IBaseEventArgs } from '../core/utils';
import { IgxDirectionality } from '../services/direction/directionality';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './progressbar.common';
import * as ɵngcc2 from '@angular/common';
export declare enum IgxTextAlign {
    START = "start",
    CENTER = "center",
    END = "end"
}
export declare enum IgxProgressType {
    ERROR = "error",
    INFO = "info",
    WARNING = "warning",
    SUCCESS = "success"
}
export interface IChangeProgressEventArgs extends IBaseEventArgs {
    previousValue: number;
    currentValue: number;
}
export declare abstract class BaseProgress {
    /**
     * @hidden
     */
    private requestAnimationId;
    /**
     * @hidden
     */
    protected _valueInPercent: number;
    /**
     * @hidden
     */
    protected _max: number;
    /**
     * @hidden
     */
    protected _value: number;
    /**
     * @hidden
     */
    protected _animate: boolean;
    /**
     * @hidden
     */
    protected _step: any;
    /**
     *Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *public valuePercent(event){
     *    let percentValue = this.progressBar.valueInPercent;
     *    alert(percentValue);
     *}
     *```
     */
    get valueInPercent(): number;
    /**
     *Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *    public setValue(event){
     *    this.progressBar.valueInPercent = 56;
     *}
     * //...
     *```
     *```html
     *<button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
     *```
     */
    set valueInPercent(value: number);
    /**
     * @hidden
     */
    protected runAnimation(val: number, step: number): void;
    /**
     * @hidden
     */
    protected updateProgressSmoothly(val: number, step: number): void;
    /**
     * @hidden
     */
    protected updateProgressDirectly(val: number): void;
    /**
     * @hidden
     */
    protected directionFlow(currentValue: number, prevValue: number, step: number): number;
    /**
     * @hidden
     */
    private isInLimitRange;
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    private isExceedingUpperLimit;
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    private isExceedingLowerLimit;
    /**
     * @hidden
     * @param step
     */
    private updateProgress;
}
export declare class IgxLinearProgressBarComponent extends BaseProgress {
    /**
     *Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
     *```html
     *<igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    set animate(animate: boolean);
    /**
     *Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     *}
     *```
     */
    get animate(): boolean;
    /**
     *Set maximum value that can be passed. By default it is set to 100.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
     *```
     */
    set max(maxNum: number);
    /**
     *Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     *}
     *```
     */
    get max(): number;
    /**
     *Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     *}
     *```
     */
    get step(): number;
    /**
     *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     *```
     */
    set step(val: number);
    constructor();
    valueMin: number;
    cssClass: string;
    /**
     *Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
     *```html
     *<igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    striped: boolean;
    /**
     *Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
     *```html
     *<igx-linear-bar [indeterminate]="true"></igx-linear-bar>
     *```
     */
    indeterminate: boolean;
    /**An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
     * ```html
     *<igx-linear-bar role="progressbar"></igx-linear-bar>
     * ```
     */
    role: string;
    /**An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     *<igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    id: string;
    /**
     *Set the position that defines where the text is aligned.
     Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
     *```typescript
     *public positionCenter: IgxTextAlign;
     *public ngOnInit() {
     *    this.positionCenter = IgxTextAlign.CENTER;
     *}
     * //...
     *```
     * ```html
     *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     *```
     */
    textAlign: IgxTextAlign;
    /**
     *Set the text to be visible. By default it is set to true.
     * ```html
     *<igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
     *```
     */
    textVisibility: boolean;
    /**
     *Set the position that defines if the text should be aligned above the progress line. By default is set to false.
     *```html
     *<igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
     *```
     */
    textTop: boolean;
    /**
     *Set a custom text that is displayed according to the defined position.
     * ```html
     *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     *```
     */
    text: string;
    /**
     *Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
     *```html
     *<igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
     *```
     */
    type: string;
    /**
    *Returns value that indicates the current `IgxLinearProgressBarComponent` position.
    *```typescript
    *@ViewChild("MyProgressBar")
    *public progressBar: IgxLinearProgressBarComponent;
    *public getValue(event) {
    *    let value = this.progressBar.value;
    *    alert(value);
    *}
    *```
    */
    get value(): number;
    /**
     *Set value that indicates the current `IgxLinearProgressBarComponent` position.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    set value(val: number);
    /**
     *An event, which is triggered after a progress is changed.
     *```typescript
     *public progressChange(event) {
     *    alert("Progress made!");
     *}
     * //...
     *```
     *```html
     *<igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
     *```
     */
    onProgressChanged: EventEmitter<IChangeProgressEventArgs>;
    /**
     * @hidden
     */
    get error(): boolean;
    /**
     * @hidden
     */
    get info(): boolean;
    /**
     * @hidden
     */
    get warning(): boolean;
    /**
     * @hidden
     */
    get success(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxLinearProgressBarComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxLinearProgressBarComponent, "igx-linear-bar", never, { "striped": "striped"; "indeterminate": "indeterminate"; "role": "role"; "id": "id"; "textAlign": "textAlign"; "textVisibility": "textVisibility"; "textTop": "textTop"; "type": "type"; "animate": "animate"; "max": "max"; "step": "step"; "value": "value"; "text": "text"; }, { "onProgressChanged": "onProgressChanged"; }, never, never>;
}
export declare class IgxCircularProgressBarComponent extends BaseProgress implements AfterViewInit {
    private renderer;
    private _directionality;
    private readonly STROKE_OPACITY_DVIDER;
    private readonly STROKE_OPACITY_ADDITION;
    /** @hidden */
    cssClass: string;
    /**
     *An event, which is triggered after a progress is changed.
     *```typescript
     *public progressChange(event) {
     *    alert("Progress made!");
     *}
     * //...
     *```
     *```html
     *<igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
     *```
     */
    onProgressChanged: EventEmitter<IChangeProgressEventArgs>;
    /**
     *An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     *```html
     *<igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
     *```
     */
    id: string;
    /**
     * @hidden
     */
    gradientId: string;
    /**
     *An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
     *```html
     *<igx-circular-bar [indeterminate]="true"></igx-circular-bar>
     *```
     */
    indeterminate: boolean;
    /**
     *Sets the text visibility. By default it is set to true.
     *```html
     *<igx-circular-bar [textVisibility]="false"></igx-circular-bar>
     *```
     */
    textVisibility: boolean;
    /**
     * Sets/gets the text to be displayed inside the `igxCircularBar`.
     *```html
     *<igx-circular-bar text="Progress"></igx-circular-bar>
     *```
     *```typescript
     *let text = this.circularBar.text;
     *```
     */
    text: string;
    textTemplate: IgxProcessBarTextTemplateDirective;
    gradientTemplate: IgxProgressBarGradientDirective;
    /**
     * @hidden
    */
    get context(): any;
    /**
    *Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
     *```html
     *<igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
     *```
     */
    set animate(animate: boolean);
    /**
     *Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     *}
     *```
     */
    get animate(): boolean;
    /**
     *Set maximum value that can be passed. By default it is set to 100.
     *```html
     *<igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     *```
     */
    set max(maxNum: number);
    /**
     *Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     *}
     *```
     *```html
     *<igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
     *```
     */
    get max(): number;
    /**
     *Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     *}
     *```
     */
    get step(): number;
    /**
     *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     *```html
     *<igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     *```
    */
    set step(val: number);
    /**
     *Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     *}
     *```
     *```html
     *<button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     *```
     */
    get value(): number;
    /**
     *Set value that indicates the current `IgxCircularProgressBarComponent` position.
     *```html
     *<igx-circular-bar [value]="50"></igx-circular-bar>
     *```
     */
    set value(val: number);
    private _circleRadius;
    private _circumference;
    private _svgCircle;
    constructor(renderer: Renderer2, _directionality: IgxDirectionality);
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    updateProgressSmoothly(val: number, step: number): void;
    /**
     * @hidden
    */
    get textContent(): string;
    /**
     * @hidden
    */
    updateProgressDirectly(val: number): void;
    private getProgress;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxCircularProgressBarComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxCircularProgressBarComponent, "igx-circular-bar", never, { "id": "id"; "indeterminate": "indeterminate"; "textVisibility": "textVisibility"; "animate": "animate"; "max": "max"; "step": "step"; "value": "value"; "text": "text"; }, { "onProgressChanged": "onProgressChanged"; }, ["textTemplate", "gradientTemplate"], never>;
}
export declare function getValueInProperRange(value: number, max: number, min?: number): number;
export declare function convertInPercentage(value: number, max: number): number;
/**
 * @hidden
 */
export declare class IgxProgressBarModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxProgressBarModule, [typeof IgxLinearProgressBarComponent, typeof IgxCircularProgressBarComponent, typeof ɵngcc1.IgxProcessBarTextTemplateDirective, typeof ɵngcc1.IgxProgressBarGradientDirective], [typeof ɵngcc2.CommonModule], [typeof IgxLinearProgressBarComponent, typeof IgxCircularProgressBarComponent, typeof ɵngcc1.IgxProcessBarTextTemplateDirective, typeof ɵngcc1.IgxProgressBarGradientDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxProgressBarModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInByb2dyZXNzYmFyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgUmVuZGVyZXIyLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLCBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9wcm9ncmVzc2Jhci5jb21tb24nO1xuaW1wb3J0IHsgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vc2VydmljZXMvZGlyZWN0aW9uL2RpcmVjdGlvbmFsaXR5JztcbmV4cG9ydCBkZWNsYXJlIGVudW0gSWd4VGV4dEFsaWduIHtcbiAgICBTVEFSVCA9IFwic3RhcnRcIixcbiAgICBDRU5URVIgPSBcImNlbnRlclwiLFxuICAgIEVORCA9IFwiZW5kXCJcbn1cbmV4cG9ydCBkZWNsYXJlIGVudW0gSWd4UHJvZ3Jlc3NUeXBlIHtcbiAgICBFUlJPUiA9IFwiZXJyb3JcIixcbiAgICBJTkZPID0gXCJpbmZvXCIsXG4gICAgV0FSTklORyA9IFwid2FybmluZ1wiLFxuICAgIFNVQ0NFU1MgPSBcInN1Y2Nlc3NcIlxufVxuZXhwb3J0IGludGVyZmFjZSBJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgcHJldmlvdXNWYWx1ZTogbnVtYmVyO1xuICAgIGN1cnJlbnRWYWx1ZTogbnVtYmVyO1xufVxuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgQmFzZVByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXF1ZXN0QW5pbWF0aW9uSWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsdWVJblBlcmNlbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tYXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWx1ZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FuaW1hdGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3RlcDogYW55O1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50OyAvLyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50XG4gICAgICpwdWJsaWMgdmFsdWVQZXJjZW50KGV2ZW50KXtcbiAgICAgKiAgICBsZXQgcGVyY2VudFZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudDtcbiAgICAgKiAgICBhbGVydChwZXJjZW50VmFsdWUpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IHZhbHVlSW5QZXJjZW50KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldHMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqICAgIHB1YmxpYyBzZXRWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudCA9IDU2O1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cInNldFZhbHVlKClcIj5zZXRWYWx1ZTwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlSW5QZXJjZW50KHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcnVuQW5pbWF0aW9uKHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlyZWN0aW9uRmxvdyhjdXJyZW50VmFsdWU6IG51bWJlciwgcHJldlZhbHVlOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0luTGltaXRSYW5nZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ1VwcGVyTGltaXQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzRXhjZWVkaW5nTG93ZXJMaW1pdDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyZXNzO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3Mge1xuICAgIC8qKlxuICAgICAqQW5pbWF0aW9uIG9uIHByb2dyZXNzIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW2FuaW1hdGVdPVwiZmFsc2VcIiBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHdoZXRoZXIgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgaGFzIGFuaW1hdGlvbiB0cnVlL2ZhbHNlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICBhbGVydChhbmltYXRpb25TdGF0dXMpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGUoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKlNldCBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZC4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gMTAwLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgbWF4KG1heE51bTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgbWF4VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgbWF4ID0gdGhpcy5wcm9ncmVzc0Jhci5tYXg7XG4gICAgICogICAgYWxlcnQobWF4KTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBtYXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzdGVwVmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgc3RlcCA9IHRoaXMucHJvZ3Jlc3NCYXIuc3RlcDtcbiAgICAgKiAgICBhbGVydChzdGVwKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBzdGVwKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpO1xuICAgIGNvbnN0cnVjdG9yKCk7XG4gICAgdmFsdWVNaW46IG51bWJlcjtcbiAgICBjc3NDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqU2V0IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdG8gaGF2ZSBzdHJpcGVkIHN0eWxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RyaXBlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKlNldCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHRvIGhhdmUgaW5kZXRlcm1pbmF0ZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBpbmRldGVybWluYXRlOiBib29sZWFuO1xuICAgIC8qKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgcm9sZWAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgcHJvZ3Jlc3NiYXJgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciByb2xlPVwicHJvZ3Jlc3NiYXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJvbGU6IHN0cmluZztcbiAgICAvKipBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtpZF09XCInaWd4LWxpbmVhci1iYXItNTUnXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgUG9zc2libGUgb3B0aW9ucyAtIGBJZ3hUZXh0QWxpZ24uU1RBUlRgIChkZWZhdWx0KSwgYElneFRleHRBbGlnbi5DRU5URVJgLCBgSWd4VGV4dEFsaWduLkVORGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcG9zaXRpb25DZW50ZXI6IElneFRleHRBbGlnbjtcbiAgICAgKnB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgKiAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogSWd4VGV4dEFsaWduO1xuICAgIC8qKlxuICAgICAqU2V0IHRoZSB0ZXh0IHRvIGJlIHZpc2libGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJkZWZhdWx0XCIgW3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHRWaXNpYmlsaXR5OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgaWYgdGhlIHRleHQgc2hvdWxkIGJlIGFsaWduZWQgYWJvdmUgdGhlIHByb2dyZXNzIGxpbmUuIEJ5IGRlZmF1bHQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJlcnJvclwiIFt0ZXh0VG9wXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgdGV4dFRvcDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKlNldCBhIGN1c3RvbSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGFjY29yZGluZyB0byB0aGUgZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqU2V0IHR5cGUgb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIFBvc3NpYmxlIG9wdGlvbnMgLSBgZGVmYXVsdGAsIGBzdWNjZXNzYCwgYGluZm9gLCBgd2FybmluZ2AsIGFuZCBgZXJyb3JgLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJlcnJvclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgKlJldHVybnMgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAqYGBgdHlwZXNjcmlwdFxuICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICpwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAqICAgIGxldCB2YWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWU7XG4gICAgKiAgICBhbGVydCh2YWx1ZSk7XG4gICAgKn1cbiAgICAqYGBgXG4gICAgKi9cbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiIHR5cGU9XCJzdWNjZXNzXCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBvblByb2dyZXNzQ2hhbmdlZDogRXZlbnRFbWl0dGVyPElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlcnJvcigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgaW5mbygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgd2FybmluZygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3VjY2VzcygpOiBib29sZWFuO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzcyBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uYWxpdHk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTjtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGNzc0NsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICpBbiBldmVudCwgd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIGEgcHJvZ3Jlc3MgaXMgY2hhbmdlZC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0NoYW5nZShldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiUHJvZ3Jlc3MgbWFkZSFcIik7XG4gICAgICp9XG4gICAgICogLy8uLi5cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChvblByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgb25Qcm9ncmVzc0NoYW5nZWQ6IEV2ZW50RW1pdHRlcjxJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdyYWRpZW50SWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXRlcm1pbmF0ZWAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBpbmRldGVybWluYXRlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgdGV4dFZpc2liaWxpdHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhlIGBpZ3hDaXJjdWxhckJhcmAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciB0ZXh0PVwiUHJvZ3Jlc3NcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKmxldCB0ZXh0ID0gdGhpcy5jaXJjdWxhckJhci50ZXh0O1xuICAgICAqYGBgXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nO1xuICAgIHRleHRUZW1wbGF0ZTogSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICBncmFkaWVudFRlbXBsYXRlOiBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCk6IGFueTtcbiAgICAvKipcbiAgICAqQW5pbWF0aW9uIG9uIHByb2dyZXNzIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHdoZXRoZXIgdGhlIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBoYXMgYW5pbWF0aW9uIHRydWUvZmFsc2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGFuaW1hdGlvblN0YXR1cyhldmVudCkge1xuICAgICAqICAgIGxldCBhbmltYXRpb25TdGF0dXMgPSB0aGlzLnByb2dyZXNzQmFyLmFuaW1hdGU7XG4gICAgICogICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBhbmltYXRlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgbWF4KG1heE51bTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IG1heCA9IHRoaXMucHJvZ3Jlc3NCYXIubWF4O1xuICAgICAqICAgIGFsZXJ0KG1heCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjQ1XCIgW2FuaW1hdGVdPVwiZmFsc2VcIiBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB2YWx1ZSB3aGljaCB1cGRhdGUgdGhlIHByb2dyZXNzIGluZGljYXRvciBvZiB0aGUgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzdGVwVmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgc3RlcCA9IHRoaXMucHJvZ3Jlc3NCYXIuc3RlcDtcbiAgICAgKiAgICBhbGVydChzdGVwKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBzdGVwKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICBhbGVydCh2YWx1ZSk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cImdldFZhbHVlKClcIj5DbGljazwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbdmFsdWVdPVwiNTBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsOiBudW1iZXIpO1xuICAgIHByaXZhdGUgX2NpcmNsZVJhZGl1cztcbiAgICBwcml2YXRlIF9jaXJjdW1mZXJlbmNlO1xuICAgIHByaXZhdGUgX3N2Z0NpcmNsZTtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcjogUmVuZGVyZXIyLCBfZGlyZWN0aW9uYWxpdHk6IElneERpcmVjdGlvbmFsaXR5KTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpOiB2b2lkO1xuICAgIHByaXZhdGUgZ2V0UHJvZ3Jlc3M7XG59XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBnZXRWYWx1ZUluUHJvcGVyUmFuZ2UodmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbj86IG51bWJlcik6IG51bWJlcjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNvbnZlcnRJblBlcmNlbnRhZ2UodmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXI7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4UHJvZ3Jlc3NCYXJNb2R1bGUge1xufVxuIl19