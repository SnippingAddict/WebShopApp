import { Transaction, State } from './transaction';
import { IgxBaseTransactionService } from './base-transaction';
import { EventEmitter } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export declare class IgxTransactionService<T extends Transaction, S extends State> extends IgxBaseTransactionService<T, S> {
    protected _transactions: T[];
    protected _redoStack: {
        transaction: T;
        recordRef: any;
    }[][];
    protected _undoStack: {
        transaction: T;
        recordRef: any;
    }[][];
    protected _states: Map<any, S>;
    /**
     * @inheritdoc
     */
    get canUndo(): boolean;
    /**
     * @inheritdoc
     */
    get canRedo(): boolean;
    /**
     * @inheritdoc
     */
    onStateUpdate: EventEmitter<void>;
    /**
     * @inheritdoc
     */
    add(transaction: T, recordRef?: any): void;
    protected addTransaction(transaction: T, states: Map<any, S>, recordRef?: any): void;
    /**
     * @inheritdoc
     */
    getTransactionLog(id?: any): T[];
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges: boolean): T[];
    /**
     * @inheritdoc
     */
    getState(id: any, pending?: boolean): S;
    /**
     * @inheritdoc
     */
    get enabled(): boolean;
    /**
     * @inheritdoc
     */
    getAggregatedValue(id: any, mergeChanges: boolean): any;
    /**
     * @inheritdoc
     */
    endPending(commit: boolean): void;
    /**
     * @inheritdoc
     */
    commit(data: any[], id?: any): void;
    /**
     * @inheritdoc
     */
    clear(id?: any): void;
    /**
     * @inheritdoc
     */
    undo(): void;
    /**
     * @inheritdoc
     */
    redo(): void;
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @param transaction Transaction to be verified
     */
    protected verifyAddedTransaction(states: Map<any, S>, transaction: T, recordRef?: any): void;
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    protected updateState(states: Map<any, S>, transaction: T, recordRef?: any): void;
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @param state State to clean
     */
    protected cleanState(id: any, states: Map<any, S>): void;
    /**
     * Updates state related record in the provided data
     * @param data Data source to update
     * @param state State to update data from
     */
    protected updateRecord(data: any[], state: S): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxTransactionService<any, any>, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IgxTransactionService<any, any>>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWd4LXRyYW5zYWN0aW9uLmQudHMiLCJzb3VyY2VzIjpbImlneC10cmFuc2FjdGlvbi5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zYWN0aW9uLCBTdGF0ZSB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgSWd4QmFzZVRyYW5zYWN0aW9uU2VydmljZSB9IGZyb20gJy4vYmFzZS10cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFRyYW5zYWN0aW9uU2VydmljZTxUIGV4dGVuZHMgVHJhbnNhY3Rpb24sIFMgZXh0ZW5kcyBTdGF0ZT4gZXh0ZW5kcyBJZ3hCYXNlVHJhbnNhY3Rpb25TZXJ2aWNlPFQsIFM+IHtcbiAgICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uczogVFtdO1xuICAgIHByb3RlY3RlZCBfcmVkb1N0YWNrOiB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBUO1xuICAgICAgICByZWNvcmRSZWY6IGFueTtcbiAgICB9W11bXTtcbiAgICBwcm90ZWN0ZWQgX3VuZG9TdGFjazoge1xuICAgICAgICB0cmFuc2FjdGlvbjogVDtcbiAgICAgICAgcmVjb3JkUmVmOiBhbnk7XG4gICAgfVtdW107XG4gICAgcHJvdGVjdGVkIF9zdGF0ZXM6IE1hcDxhbnksIFM+O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgZ2V0IGNhblVuZG8oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIGdldCBjYW5SZWRvKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBvblN0YXRlVXBkYXRlOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBhZGQodHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGFkZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBULCBzdGF0ZXM6IE1hcDxhbnksIFM+LCByZWNvcmRSZWY/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25Mb2coaWQ/OiBhbnkpOiBUW107XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRBZ2dyZWdhdGVkQ2hhbmdlcyhtZXJnZUNoYW5nZXM6IGJvb2xlYW4pOiBUW107XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRTdGF0ZShpZDogYW55LCBwZW5kaW5nPzogYm9vbGVhbik6IFM7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXQgZW5hYmxlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgZ2V0QWdncmVnYXRlZFZhbHVlKGlkOiBhbnksIG1lcmdlQ2hhbmdlczogYm9vbGVhbik6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIGVuZFBlbmRpbmcoY29tbWl0OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIGNvbW1pdChkYXRhOiBhbnlbXSwgaWQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgY2xlYXIoaWQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgdW5kbygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgcmVkbygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb24gaXMgY29ycmVjdC4gSWYgbm90IHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGJlIHZlcmlmaWVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHZlcmlmeUFkZGVkVHJhbnNhY3Rpb24oc3RhdGVzOiBNYXA8YW55LCBTPiwgdHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgc3RhdGVzIGNvbGxlY3Rpb24gYWNjb3JkaW5nIHRvIHBhc3NlZCB0cmFuc2FjdGlvbiBhbmQgcmVjb3JkUmVmXG4gICAgICogQHBhcmFtIHN0YXRlcyBTdGF0ZXMgY29sbGVjdGlvbiB0byBhcHBseSB0aGUgdXBkYXRlIHRvXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGFwcGx5IHRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICogQHBhcmFtIHJlY29yZFJlZiBSZWZlcmVuY2UgdG8gdGhlIHZhbHVlIG9mIHRoZSByZWNvcmQgaW4gZGF0YSBzb3VyY2UsIGlmIGFueSwgd2hlcmUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlU3RhdGUoc3RhdGVzOiBNYXA8YW55LCBTPiwgdHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIHN0YXRlIHdpdGggcmVjb3JkUmVmIGFuZCBjbGVhcnMgYWxsIGR1cGxpY2F0ZWQgdmFsdWVzLiBJZiBhbnkgc3RhdGUgZW5kcyBhc1xuICAgICAqIGVtcHR5IG9iamVjdCByZW1vdmVzIGl0IGZyb20gc3RhdGVzLlxuICAgICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSB0byBjbGVhblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjbGVhblN0YXRlKGlkOiBhbnksIHN0YXRlczogTWFwPGFueSwgUz4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgcmVsYXRlZCByZWNvcmQgaW4gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHNvdXJjZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgdG8gdXBkYXRlIGRhdGEgZnJvbVxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVSZWNvcmQoZGF0YTogYW55W10sIHN0YXRlOiBTKTogdm9pZDtcbn1cbiJdfQ==