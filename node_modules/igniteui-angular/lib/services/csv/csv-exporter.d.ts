import { EventEmitter } from '@angular/core';
import { IgxBaseExporter } from '../exporter-common/base-export-service';
import { IgxCsvExporterOptions } from './csv-exporter-options';
import { IBaseEventArgs } from '../../core/utils';
import * as ɵngcc0 from '@angular/core';
export interface ICsvExportEndedEventArgs extends IBaseEventArgs {
    csvData: string;
}
/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
export declare class IgxCsvExporterService extends IgxBaseExporter {
    private _stringData;
    /**
     * This event is emitted when the export process finishes.
     * ```typescript
     * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
     * // put event handler code here
     * });
     * ```
     * @memberof IgxCsvExporterService
     */
    onExportEnded: EventEmitter<ICsvExportEndedEventArgs>;
    protected exportDataImplementation(data: any[], options: IgxCsvExporterOptions): void;
    private saveFile;
    private exportFile;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxCsvExporterService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IgxCsvExporterService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3N2LWV4cG9ydGVyLmQudHMiLCJzb3VyY2VzIjpbImNzdi1leHBvcnRlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4QmFzZUV4cG9ydGVyIH0gZnJvbSAnLi4vZXhwb3J0ZXItY29tbW9uL2Jhc2UtZXhwb3J0LXNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Q3N2RXhwb3J0ZXJPcHRpb25zIH0gZnJvbSAnLi9jc3YtZXhwb3J0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuZXhwb3J0IGludGVyZmFjZSBJQ3N2RXhwb3J0RW5kZWRFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgY3N2RGF0YTogc3RyaW5nO1xufVxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBDU1YgRXhwb3J0ZXIgU2VydmljZSoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9leHBvcnRlcl9jc3YuaHRtbClcbiAqXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIENTViBFeHBvcnRlciBzZXJ2aWNlIGNhbiBleHBvcnQgZGF0YSBpbiBhIENoYXJhY3RlciBTZXBhcmF0ZWQgVmFsdWVzIGZvcm1hdCBmcm9tXG4gKiBib3RoIHJhdyBkYXRhIChhcnJheSkgb3IgZnJvbSBhbiBgSWd4R3JpZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHB1YmxpYyBsb2NhbERhdGEgPSBbXG4gKiAgIHsgTmFtZTogXCJFcmljIFJpZGxleVwiLCBBZ2U6IFwiMjZcIiB9LFxuICogICB7IE5hbWU6IFwiQWxhbmlzIEJyb29rXCIsIEFnZTogXCIyMlwiIH0sXG4gKiAgIHsgTmFtZTogXCJKb25hdGhhbiBNb3JyaXNcIiwgQWdlOiBcIjIzXCIgfVxuICogXTtcbiAqXG4gKiBjb25zdHJ1Y3Rvcihwcml2YXRlIGNzdkV4cG9ydFNlcnZpY2U6IElneENzdkV4cG9ydGVyU2VydmljZSkge1xuICogfVxuICpcbiAqIGNvbnN0IG9wdDogSWd4Q3N2RXhwb3J0ZXJPcHRpb25zID0gbmV3IElneENzdkV4cG9ydGVyT3B0aW9ucyhcIkZpbGVOYW1lXCIsIENzdkZpbGVUeXBlcy5DU1YpO1xuICogdGhpcy5jc3ZFeHBvcnRTZXJ2aWNlLmV4cG9ydERhdGEodGhpcy5sb2NhbERhdGEsIG9wdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4Q3N2RXhwb3J0ZXJTZXJ2aWNlIGV4dGVuZHMgSWd4QmFzZUV4cG9ydGVyIHtcbiAgICBwcml2YXRlIF9zdHJpbmdEYXRhO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBleHBvcnQgcHJvY2VzcyBmaW5pc2hlcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5leHBvcnRlclNlcnZpY2Uub25FeHBvcnRFbmRlZC5zdWJzY3JpYmUoKGFyZ3M6IElDc3ZFeHBvcnRFbmRlZEV2ZW50QXJncykgPT4ge1xuICAgICAqIC8vIHB1dCBldmVudCBoYW5kbGVyIGNvZGUgaGVyZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDc3ZFeHBvcnRlclNlcnZpY2VcbiAgICAgKi9cbiAgICBvbkV4cG9ydEVuZGVkOiBFdmVudEVtaXR0ZXI8SUNzdkV4cG9ydEVuZGVkRXZlbnRBcmdzPjtcbiAgICBwcm90ZWN0ZWQgZXhwb3J0RGF0YUltcGxlbWVudGF0aW9uKGRhdGE6IGFueVtdLCBvcHRpb25zOiBJZ3hDc3ZFeHBvcnRlck9wdGlvbnMpOiB2b2lkO1xuICAgIHByaXZhdGUgc2F2ZUZpbGU7XG4gICAgcHJpdmF0ZSBleHBvcnRGaWxlO1xufVxuIl19