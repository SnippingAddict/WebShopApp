import { Observable } from 'rxjs';
/**
 *@hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare function cloneArray(array: any[], deep?: boolean): any[];
/**
 * Doesn't clone leaf items
 * @hidden
 */
export declare function cloneHierarchicalArray(array: any[], childDataKey: any): any[];
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export declare function mergeObjects(obj1: {}, obj2: {}): any;
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 *@hidden
 */
export declare function cloneValue(value: any): any;
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 *@hidden
 */
export declare function isObject(value: any): boolean;
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 *@hidden
 */
export declare function isDate(value: any): boolean;
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export declare function isEqual(obj1: any, obj2: any): boolean;
/**
 *@hidden
 */
export declare const enum KEYCODES {
    ENTER = 13,
    SPACE = 32,
    ESCAPE = 27,
    LEFT_ARROW = 37,
    UP_ARROW = 38,
    RIGHT_ARROW = 39,
    DOWN_ARROW = 40,
    F2 = 113,
    TAB = 9
}
/**
 *@hidden
 */
export declare const enum KEYS {
    ENTER = "Enter",
    SPACE = " ",
    SPACE_IE = "Spacebar",
    ESCAPE = "Escape",
    ESCAPE_IE = "Esc",
    LEFT_ARROW = "ArrowLeft",
    LEFT_ARROW_IE = "Left",
    UP_ARROW = "ArrowUp",
    UP_ARROW_IE = "Up",
    RIGHT_ARROW = "ArrowRight",
    RIGHT_ARROW_IE = "Right",
    DOWN_ARROW = "ArrowDown",
    DOWN_ARROW_IE = "Down",
    F2 = "F2",
    TAB = "Tab",
    HOME = "Home",
    END = "End"
}
/**
 *@hidden
* Returns the actual size of the node content, using Range
* ```typescript
* let range = document.createRange();
* let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
*
* let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
* ```
 */
export declare function getNodeSizeViaRange(range: Range, node: any): number;
/**
 *@hidden
* Returns the actual size of the node content, using Canvas
* ```typescript
* let ctx = document.createElement('canvas').getContext('2d');
* let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
*
* let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
* ```
 */
export declare function getNodeSizeViaCanvas(canvas2dCtx: any, node: any): number;
/**
 *@hidden
 */
export declare function isIE(): boolean;
/**
 *@hidden
 */
export declare function isEdge(): boolean;
/**
 *@hidden
 */
export declare function isFirefox(): boolean;
/**
 * @hidden
 */
export declare class PlatformUtil {
    private platformId;
    isBrowser: boolean;
    isIOS: boolean;
    constructor(platformId: Object);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PlatformUtil, never>;
}
/**
 * @hidden
 */
export declare function isLeftClick(event: PointerEvent): boolean;
/** @hidden */
export declare function isNavigationKey(key: string): boolean;
/**
 *@hidden
 */
export declare function flatten(arr: any[]): any[];
export interface CancelableEventArgs {
    /**
     * Provides the ability to cancel the event.
     */
    cancel: boolean;
}
export interface IBaseEventArgs {
    /**
     * Provides reference to the owner component.
     */
    owner?: any;
}
export interface CancelableBrowserEventArgs extends CancelableEventArgs {
    /** Browser event */
    event?: Event;
}
export declare const NAVIGATION_KEYS: Set<string>;
export declare const ROW_EXPAND_KEYS: Set<string>;
export declare const ROW_COLLAPSE_KEYS: Set<string>;
export declare const SUPPORTED_KEYS: Set<string>;
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export declare function resizeObservable(target: HTMLElement): Observable<ResizeObserverEntry[]>;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuZC50cyIsInNvdXJjZXMiOlsidXRpbHMuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXk6IGFueVtdLCBkZWVwPzogYm9vbGVhbik6IGFueVtdO1xuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gY2xvbmVIaWVyYXJjaGljYWxBcnJheShhcnJheTogYW55W10sIGNoaWxkRGF0YUtleTogYW55KTogYW55W107XG4vKipcbiAqIERlZXAgY2xvbmVzIGFsbCBmaXJzdCBsZXZlbCBrZXlzIG9mIE9iajIgYW5kIG1lcmdlcyB0aGVtIHRvIE9iajFcbiAqIEBwYXJhbSBvYmoxIE9iamVjdCB0byBtZXJnZSBpbnRvXG4gKiBAcGFyYW0gb2JqMiBPYmplY3QgdG8gbWVyZ2UgZnJvbVxuICogQHJldHVybnMgT2JqMSB3aXRoIG1lcmdlZCBjbG9uZWQga2V5cyBmcm9tIE9iajJcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajE6IHt9LCBvYmoyOiB7fSk6IGFueTtcbi8qKlxuICogQ3JlYXRlcyBkZWVwIGNsb25lIG9mIHByb3ZpZGVkIHZhbHVlLlxuICogU3VwcG9ydHMgcHJpbWl0aXZlIHZhbHVlcywgZGF0ZXMgYW5kIG9iamVjdHMuXG4gKiBJZiBwYXNzZWQgdmFsdWUgaXMgYXJyYXkgcmV0dXJucyBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJucyBEZWVwIGNvcHkgb2YgcHJvdmlkZWQgdmFsdWVcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlOiBhbnkpOiBhbnk7XG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbjtcbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpOiBib29sZWFuO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHR3byBwYXNzZWQgYXJndW1lbnRzIGFyZSBlcXVhbFxuICogQ3VycmVudGx5IHN1cHBvcnRzIGRhdGUgb2JqZWN0c1xuICogQHBhcmFtIG9iajFcbiAqIEBwYXJhbSBvYmoyXG4gKiBAcmV0dXJuczogYGJvb2xlYW5gXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGlzRXF1YWwob2JqMTogYW55LCBvYmoyOiBhbnkpOiBib29sZWFuO1xuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgZW51bSBLRVlDT0RFUyB7XG4gICAgRU5URVIgPSAxMyxcbiAgICBTUEFDRSA9IDMyLFxuICAgIEVTQ0FQRSA9IDI3LFxuICAgIExFRlRfQVJST1cgPSAzNyxcbiAgICBVUF9BUlJPVyA9IDM4LFxuICAgIFJJR0hUX0FSUk9XID0gMzksXG4gICAgRE9XTl9BUlJPVyA9IDQwLFxuICAgIEYyID0gMTEzLFxuICAgIFRBQiA9IDlcbn1cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IGVudW0gS0VZUyB7XG4gICAgRU5URVIgPSBcIkVudGVyXCIsXG4gICAgU1BBQ0UgPSBcIiBcIixcbiAgICBTUEFDRV9JRSA9IFwiU3BhY2ViYXJcIixcbiAgICBFU0NBUEUgPSBcIkVzY2FwZVwiLFxuICAgIEVTQ0FQRV9JRSA9IFwiRXNjXCIsXG4gICAgTEVGVF9BUlJPVyA9IFwiQXJyb3dMZWZ0XCIsXG4gICAgTEVGVF9BUlJPV19JRSA9IFwiTGVmdFwiLFxuICAgIFVQX0FSUk9XID0gXCJBcnJvd1VwXCIsXG4gICAgVVBfQVJST1dfSUUgPSBcIlVwXCIsXG4gICAgUklHSFRfQVJST1cgPSBcIkFycm93UmlnaHRcIixcbiAgICBSSUdIVF9BUlJPV19JRSA9IFwiUmlnaHRcIixcbiAgICBET1dOX0FSUk9XID0gXCJBcnJvd0Rvd25cIixcbiAgICBET1dOX0FSUk9XX0lFID0gXCJEb3duXCIsXG4gICAgRjIgPSBcIkYyXCIsXG4gICAgVEFCID0gXCJUYWJcIixcbiAgICBIT01FID0gXCJIb21lXCIsXG4gICAgRU5EID0gXCJFbmRcIlxufVxuLyoqXG4gKkBoaWRkZW5cbiogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgUmFuZ2VcbiogYGBgdHlwZXNjcmlwdFxuKiBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4qXG4qIGxldCBzaXplID0gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZTogUmFuZ2UsIG5vZGU6IGFueSk6IG51bWJlcjtcbi8qKlxuICpAaGlkZGVuXG4qIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIENhbnZhc1xuKiBgYGB0eXBlc2NyaXB0XG4qIGxldCBjdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4qXG4qIGxldCBzaXplID0gdmFsVG9QeGxzVXNpbmdDYW52YXMoY3R4LCBjb2x1bW4uY2VsbHNbMF0ubmF0aXZlRWxlbWVudCk7XG4qIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYUNhbnZhcyhjYW52YXMyZEN0eDogYW55LCBub2RlOiBhbnkpOiBudW1iZXI7XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW47XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc0VkZ2UoKTogYm9vbGVhbjtcbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGlzRmlyZWZveCgpOiBib29sZWFuO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFBsYXRmb3JtVXRpbCB7XG4gICAgcHJpdmF0ZSBwbGF0Zm9ybUlkO1xuICAgIGlzQnJvd3NlcjogYm9vbGVhbjtcbiAgICBpc0lPUzogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybUlkOiBPYmplY3QpO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGlzTGVmdENsaWNrKGV2ZW50OiBQb2ludGVyRXZlbnQpOiBib29sZWFuO1xuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGlzTmF2aWdhdGlvbktleShrZXk6IHN0cmluZyk6IGJvb2xlYW47XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBmbGF0dGVuKGFycjogYW55W10pOiBhbnlbXTtcbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWZlcmVuY2UgdG8gdGhlIG93bmVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvd25lcj86IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKiogQnJvd3NlciBldmVudCAqL1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBOQVZJR0FUSU9OX0tFWVM6IFNldDxzdHJpbmc+O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgUk9XX0VYUEFORF9LRVlTOiBTZXQ8c3RyaW5nPjtcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IFJPV19DT0xMQVBTRV9LRVlTOiBTZXQ8c3RyaW5nPjtcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IFNVUFBPUlRFRF9LRVlTOiBTZXQ8c3RyaW5nPjtcbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKlxuICogQ3JlYXRlcyBhIG5ldyBSZXNpemVPYnNlcnZlciBvbiBgdGFyZ2V0YCBhbmQgcmV0dXJucyBpdCBhcyBhbiBPYnNlcnZhYmxlLlxuICogUnVuIHRoZSByZXNpemVPYnNlcnZhYmxlIG91dHNpZGUgYW5ndWxhciB6b25lLCBiZWNhdXNlIGl0IHBhdGNoZXMgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgd2hpY2ggY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuXG4gKiBSZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTcxMlxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiByZXNpemVPYnNlcnZhYmxlKHRhcmdldDogSFRNTEVsZW1lbnQpOiBPYnNlcnZhYmxlPFJlc2l6ZU9ic2VydmVyRW50cnlbXT47XG4iXX0=