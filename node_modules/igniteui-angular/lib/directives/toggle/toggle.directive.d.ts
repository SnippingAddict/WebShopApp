import { ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { IgxNavigationService, IToggleView } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { OverlaySettings } from '../../services';
import { CancelableEventArgs, CancelableBrowserEventArgs, IBaseEventArgs } from '../../core/utils';
import * as ɵngcc0 from '@angular/core';
export declare class IgxToggleDirective implements IToggleView, OnInit, OnDestroy {
    private elementRef;
    private cdr;
    protected overlayService: IgxOverlayService;
    private navigationService;
    protected _overlayId: string;
    private destroy$;
    private _overlaySubFilter;
    private _overlayOpenedSub;
    private _overlayClosingSub;
    private _overlayClosedSub;
    private _overlayAppendedSub;
    /**
     * Emits an event after the toggle container is opened.
     *
     * ```typescript
     * onToggleOpened(event) {
     *    alert("Toggle opened!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpened)='onToggleOpened($event)'>
     * </div>
     * ```
     */
    onOpened: EventEmitter<any>;
    /**
     * Emits an event before the toggle container is opened.
     *
     * ```typescript
     * onToggleOpening(event) {
     *  alert("Toggle opening!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpening)='onToggleOpening($event)'>
     * </div>
     * ```
     */
    onOpening: EventEmitter<CancelableEventArgs & IBaseEventArgs>;
    /**
     * Emits an event after the toggle container is closed.
     *
     * ```typescript
     * onToggleClosed(event) {
     *  alert("Toggle closed!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onClosed)='onToggleClosed($event)'>
     * </div>
     * ```
     */
    onClosed: EventEmitter<any>;
    /**
     * Emits an event before the toggle container is closed.
     *
     * ```typescript
     * onToggleClosing(event) {
     *  alert("Toggle closing!");
     * }
     * ```
     *
     * ```html
     * <div
     *  igxToggle
     *  (onClosing)='onToggleClosing($event)'>
     * </div>
     * ```
     */
    onClosing: EventEmitter<CancelableBrowserEventArgs & IBaseEventArgs>;
    private _collapsed;
    /**
     * @hidden
     */
    get collapsed(): boolean;
    /**
     * Identifier which is registered into `IgxNavigationService`
     *
     * ```typescript
     * let myToggleId = this.toggle.id;
     * ```
     */
    id: string;
    /**
     * @hidden
     */
    get element(): HTMLElement;
    /**
     * @hidden
     */
    get hiddenClass(): boolean;
    /**
     * @hidden
     */
    get defaultClass(): boolean;
    /**
     * @hidden
     */
    constructor(elementRef: ElementRef, cdr: ChangeDetectorRef, overlayService: IgxOverlayService, navigationService: IgxNavigationService);
    /**
     * Emits an event after the toggle element is appended to the overlay container.
     *
     * ```typescript
     * onAppended() {
     *  alert("Content appended!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onAppended)='onToggleAppended()'>
     * </div>
     * ```
     */
    onAppended: EventEmitter<any>;
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings?: OverlaySettings): void;
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close(): void;
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings?: OverlaySettings): void;
    /** @hidden @internal */
    get isClosing(): false | import("@angular/animations").AnimationPlayer;
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition(): void;
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX: number, deltaY: number): void;
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    private overlayClosed;
    private unsubscribe;
    private clearSubscription;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxToggleDirective, [null, null, null, { optional: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxToggleDirective, "[igxToggle]", ["toggle"], { "id": "id"; }, { "onOpened": "onOpened"; "onOpening": "onOpening"; "onClosed": "onClosed"; "onClosing": "onClosing"; "onAppended": "onAppended"; }, never>;
}
export declare class IgxToggleActionDirective implements OnInit {
    private element;
    private navigationService;
    protected _overlayDefaults: OverlaySettings;
    /**
     * Provide settings that control the toggle overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: false,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <!--set-->
     * <div igxToggleAction [overlaySettings]="settings"></div>
     * ```
     */
    overlaySettings: OverlaySettings;
    /**
     * Determines where the toggle element overlay should be attached.
     *
     * ```html
     * <!--set-->
     * <div igxToggleAction [igxToggleOutlet]="outlet"></div>
     * ```
     * Where `outlet` in an instance of `IgxOverlayOutletDirective` or an `ElementRef`
     */
    outlet: IgxOverlayOutletDirective | ElementRef;
    /**
     * @hidden
     */
    set target(target: any);
    /**
     * @hidden
     */
    get target(): any;
    protected _target: IToggleView | string;
    constructor(element: ElementRef, navigationService: IgxNavigationService);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    onClick(): void;
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    protected updateOverlaySettings(settings: OverlaySettings): OverlaySettings;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxToggleActionDirective, [null, { optional: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxToggleActionDirective, "[igxToggleAction]", ["toggle-action"], { "target": "igxToggleAction"; "overlaySettings": "overlaySettings"; "outlet": "igxToggleOutlet"; }, {}, never>;
}
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export declare class IgxOverlayOutletDirective {
    element: ElementRef;
    constructor(element: ElementRef);
    /** @hidden */
    get nativeElement(): any;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxOverlayOutletDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxOverlayOutletDirective, "[igxOverlayOutlet]", ["overlay-outlet"], {}, {}, never>;
}
/**
 * @hidden
 */
export declare class IgxToggleModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxToggleModule, [typeof IgxToggleDirective, typeof IgxToggleActionDirective, typeof IgxOverlayOutletDirective], never, [typeof IgxToggleDirective, typeof IgxToggleActionDirective, typeof IgxOverlayOutletDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxToggleModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJ0b2dnbGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uLy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQgeyBPdmVybGF5U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlRXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFRvZ2dsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIElUb2dnbGVWaWV3LCBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmO1xuICAgIHByaXZhdGUgY2RyO1xuICAgIHByb3RlY3RlZCBvdmVybGF5U2VydmljZTogSWd4T3ZlcmxheVNlcnZpY2U7XG4gICAgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlJZDogc3RyaW5nO1xuICAgIHByaXZhdGUgZGVzdHJveSQ7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVN1YkZpbHRlcjtcbiAgICBwcml2YXRlIF9vdmVybGF5T3BlbmVkU3ViO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zaW5nU3ViO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zZWRTdWI7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUFwcGVuZGVkU3ViO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZU9wZW5lZChldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiVG9nZ2xlIG9wZW5lZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uT3BlbmVkKT0nb25Ub2dnbGVPcGVuZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25PcGVuZWQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGJlZm9yZSB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVPcGVuaW5nKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIG9wZW5pbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvbk9wZW5pbmcpPSdvblRvZ2dsZU9wZW5pbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25PcGVuaW5nOiBFdmVudEVtaXR0ZXI8Q2FuY2VsYWJsZUV2ZW50QXJncyAmIElCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVDbG9zZWQoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25DbG9zZWQpPSdvblRvZ2dsZUNsb3NlZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbkNsb3NlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NpbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2luZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgaWd4VG9nZ2xlXG4gICAgICogIChvbkNsb3NpbmcpPSdvblRvZ2dsZUNsb3NpbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25DbG9zaW5nOiBFdmVudEVtaXR0ZXI8Q2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgJiBJQmFzZUV2ZW50QXJncz47XG4gICAgcHJpdmF0ZSBfY29sbGFwc2VkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllciB3aGljaCBpcyByZWdpc3RlcmVkIGludG8gYElneE5hdmlnYXRpb25TZXJ2aWNlYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBteVRvZ2dsZUlkID0gdGhpcy50b2dnbGUuaWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoaWRkZW5DbGFzcygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdENsYXNzKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQXBwZW5kZWQoKSB7XG4gICAgICogIGFsZXJ0KFwiQ29udGVudCBhcHBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQXBwZW5kZWQpPSdvblRvZ2dsZUFwcGVuZGVkKCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQXBwZW5kZWQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb3BlbihvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdG9nZ2xlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUuY2xvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjbG9zZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9nZ2xlLCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0b2dnbGUob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKTogdm9pZDtcbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgaXNDbG9zaW5nKCk6IGZhbHNlIHwgaW1wb3J0KFwiQGFuZ3VsYXIvYW5pbWF0aW9uc1wiKS5BbmltYXRpb25QbGF5ZXI7XG4gICAgLyoqXG4gICAgICogUmVwb3NpdGlvbnMgdGhlIHRvZ2dsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5yZXBvc2l0aW9uKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVwb3NpdGlvbigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE9mZnNldHMgdGhlIGNvbnRlbnQgYWxvbmcgdGhlIGNvcnJlc3BvbmRpbmcgYXhpcyBieSB0aGUgcHJvdmlkZWQgYW1vdW50XG4gICAgICovXG4gICAgc2V0T2Zmc2V0KGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBvdmVybGF5Q2xvc2VkO1xuICAgIHByaXZhdGUgdW5zdWJzY3JpYmU7XG4gICAgcHJpdmF0ZSBjbGVhclN1YnNjcmlwdGlvbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJpdmF0ZSBlbGVtZW50O1xuICAgIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U7XG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBQcm92aWRlIHNldHRpbmdzIHRoYXQgY29udHJvbCB0aGUgdG9nZ2xlIG92ZXJsYXkgcG9zaXRpb25pbmcsIGludGVyYWN0aW9uIGFuZCBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICogICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiBmYWxzZSxcbiAgICAgKiAgICAgIG1vZGFsOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICogLS0tXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbb3ZlcmxheVNldHRpbmdzXT1cInNldHRpbmdzXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3M7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGVyZSB0aGUgdG9nZ2xlIGVsZW1lbnQgb3ZlcmxheSBzaG91bGQgYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtpZ3hUb2dnbGVPdXRsZXRdPVwib3V0bGV0XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogV2hlcmUgYG91dGxldGAgaW4gYW4gaW5zdGFuY2Ugb2YgYElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmVgIG9yIGFuIGBFbGVtZW50UmVmYFxuICAgICAqL1xuICAgIG91dGxldDogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB8IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCB0YXJnZXQodGFyZ2V0OiBhbnkpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCk6IGFueTtcbiAgICBwcm90ZWN0ZWQgX3RhcmdldDogSVRvZ2dsZVZpZXcgfCBzdHJpbmc7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZiwgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25DbGljaygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcHJvdmlkZWQgb3ZlcmxheSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBzZXR0aW5ncyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyByZXR1cm5zIHVwZGF0ZWQgY29weSBvZiBwcm92aWRlZCBvdmVybGF5IHNldHRpbmdzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZU92ZXJsYXlTZXR0aW5ncyhzZXR0aW5nczogT3ZlcmxheVNldHRpbmdzKTogT3ZlcmxheVNldHRpbmdzO1xufVxuLyoqXG4gKiBNYXJrIGFuIGVsZW1lbnQgYXMgYW4gaWd4T3ZlcmxheSBvdXRsZXQgY29udGFpbmVyLlxuICogRGlyZWN0aXZlIGluc3RhbmNlIGlzIGV4cG9ydGVkIGFzIGBvdmVybGF5LW91dGxldGAgdG8gYmUgYXNzaWduZWQgdG8gdGVtcGxhdGVzIHZhcmlhYmxlczpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgaWd4T3ZlcmxheU91dGxldCAjb3V0bGV0PVwib3ZlcmxheS1vdXRsZXRcIj48L2Rpdj5cbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHtcbiAgICBlbGVtZW50OiBFbGVtZW50UmVmO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWYpO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZ2V0IG5hdGl2ZUVsZW1lbnQoKTogYW55O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFRvZ2dsZU1vZHVsZSB7XG59XG4iXX0=